{
    "version": "https://jsonfeed.org/version/1",
    "title": "潇潇先生个人博客",
    "subtitle": "",
    "icon": "http://whw-colab.github.io/images/favicon.ico",
    "description": "学习永无止尽，奋斗永不停歇",
    "home_page_url": "http://Whw-colab.github.io",
    "items": [
        {
            "id": "http://whw-colab.github.io/2025/04/17/CTF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
            "url": "http://whw-colab.github.io/2025/04/17/CTF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
            "title": "CTF学习笔记",
            "date_published": "2025-04-17T04:12:57.000Z",
            "content_html": "<h1 id=\"ctf学习笔记\"><a class=\"anchor\" href=\"#ctf学习笔记\">❡</a> CTF 学习笔记</h1>\n<h2 id=\"ctf\"><a class=\"anchor\" href=\"#ctf\">❡</a> CTF</h2>\n<h3 id=\"定义\"><a class=\"anchor\" href=\"#定义\">❡</a> 定义</h3>\n<p>CTF 就像一场 “黑客版的寻宝游戏”，参赛者通过破解密码、挖漏洞、逆向程序等技术手段，在虚拟世界里找到隐藏的 “flag”（一串特定字符），谁找得快、技术强谁就赢。</p>\n<h3 id=\"竞赛模式\"><a class=\"anchor\" href=\"#竞赛模式\">❡</a> 竞赛模式</h3>\n<ol>\n<li>\n<p>解题模式（Jeopardy）</p>\n<p><em><strong>* 核心机制 *</strong></em>：通过解决安全技术题目获取 flag，按题目分值和解题时间排名，常见于线上选拔赛。</p>\n<p><em><strong>* 动态积分规则 *</strong></em>：题目初始分值随解题人数增加而递减，前三名（一血、二血、三血）获得额外奖励分。</p>\n<p><em><strong>* 题型分类 *</strong></em>：Web 渗透、逆向工程、密码学、安全杂项（MISC）、二进制漏洞（PWN）等。</p>\n<p><strong>玩法</strong>：像<mark>做试卷</mark>，题目分类型（如密码破译、逆向工程、Web 漏洞等），解出题目后提交隐藏的 flag 就能得分。</p>\n<p><strong>特点</strong>：</p>\n<ul>\n<li>题目难度越高分越多，但解题人数越多分越少（动态积分）。</li>\n<li>适合线上赛，比如预选赛，团队可自由组队，拼脑力和技术积累。</li>\n</ul>\n<p><strong>举例</strong>：给你一个网站，找 SQL 注入漏洞拿 flag，类似 “黑客版奥数题”。</p>\n</li>\n<li>\n<p>攻防模式（Attack-Defense） （<mark>黑客版真人 CS**</mark>）</p>\n<p><em><strong>* 核心机制 *</strong></em>：各队伍拥有相同漏洞的服务器（GameBox），攻击对手服务得分，修补自身漏洞防御扣分，实时对抗性强。</p>\n<p><em><strong>* 计分规则 *</strong></em>：每轮得分取决于攻击成功次数和防御状态，服务宕机将扣分。</p>\n<p><em><strong>* 特点 *</strong></em>：高强度持续 24-48 小时，考验团队协作和体力。</p>\n</li>\n<li>\n<p><strong>ADP 攻防增强模式</strong></p>\n<p>一句话总结就是 ==<strong>“黑客版的一题两吃”</strong>==：每个题目只需完成一次攻击（拿 flag）和一次防御（修漏洞），做完就扔，不用反复折腾。</p>\n<h3 id=\"举个栗子\"><a class=\"anchor\" href=\"#举个栗子\">❡</a> <strong>举个栗子🌰：</strong></h3>\n<p>​\t假设题目是一个<strong>带漏洞的网站</strong>，ADP 模式下你要做两件事：</p>\n<p>​\t\t1️⃣ <strong>攻击</strong>：找到漏洞（比如 SQL 注入），拿到 flag 提交得分（类似解题模式）。</p>\n<p>​\t\t2️⃣ <strong>防御</strong>：给漏洞打补丁（比如过滤 SQL 语句），上传补丁到平台验证，确认修好后得分。</p>\n<p>​\t<strong>这题就算完事了！</strong> 之后不用再管它，专心搞其他题目就行。</p>\n<h3 id=\"和传统攻防awd的区别\"><a class=\"anchor\" href=\"#和传统攻防awd的区别\">❡</a> <strong>和传统攻防（AwD）的区别</strong>：</h3>\n<table>\n<thead>\n<tr>\n<th><strong>对比项</strong></th>\n<th><strong>传统攻防（AwD）</strong></th>\n<th><strong>ADP 攻防增强</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>攻击方式</strong></td>\n<td>全程用脚本批量攻击对手，抢 flag 刷分</td>\n<td>每个题只需攻击一次，提交 flag 就停手</td>\n</tr>\n<tr>\n<td><strong>防御方式</strong></td>\n<td>边修漏洞边防对手攻击，服务崩了会疯狂扣分</td>\n<td>修好漏洞并验证通过后，这题永远不扣分了</td>\n</tr>\n<tr>\n<td><strong>选手压力</strong></td>\n<td>熬夜修漏洞 + 写攻击脚本，像打仗一样累</td>\n<td>像做作业，一题两步骤，做完就躺平</td>\n</tr>\n<tr>\n<td><strong>主办方压力</strong></td>\n<td>要维护几十台服务器，防止被选手打崩</td>\n<td>题目环境用完就删，省电省服务器</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"adp的核心优势\"><a class=\"anchor\" href=\"#adp的核心优势\">❡</a> <strong>ADP 的核心优势</strong>：</h3>\n<ol>\n<li><strong>选手省力</strong>：不用写自动化脚本，不用盯着服务是否崩溃，专注解题和修漏洞本身。</li>\n<li><strong>主办方省钱</strong>：题目环境用完就销毁，不用扛住几百个队伍的持续攻击。</li>\n<li><strong>题目灵活</strong>：比赛过程中可以随时换题（比如旧题下线，新题上线），增加新鲜感。</li>\n</ol>\n<h3 id=\"适合谁玩\"><a class=\"anchor\" href=\"#适合谁玩\">❡</a> <strong>适合谁玩？</strong></h3>\n<ul>\n<li><strong>新手友好</strong>：适合刚接触攻防模式的小白，<mark>不用学写攻击脚本</mark>。</li>\n<li><strong>中小型比赛</strong>：比如企业内训、高校校赛，运维成本低。</li>\n<li><mark><strong>专精 Web/PWN 的选手</strong></mark>：ADP 通常只出这两种题型，其他方向（如逆向、密码学）不参与。</li>\n</ul>\n<p><strong>总结</strong>：<mark>ADP 就是 **“简化版攻防”**，把持续对抗拆成单次任务，让选手和主办方都轻松点～</mark></p>\n</li>\n<li>\n<p>混合模式（Mix） （<mark><strong>解题 + 攻防二合一</strong></mark>）</p>\n</li>\n</ol>\n<p><em><strong>* 机制 *</strong></em>：结合解题与攻防，解题获取基础分后进入攻防对抗，分数动态增减。</p>\n<p><em><strong>* 典型赛事 *</strong></em>：iCTF 国际赛、RealWorld CTF（RWCTF）。</p>\n<ol start=\"5\">\n<li>其他衍生模式</li>\n</ol>\n<p>​\t<em><strong>*KoH（抢占山头）*</strong></em>：攻击并控制中央服务器，写入队伍标识后防御加固，定期判定得分。</p>\n<p>​\t<mark><strong>RW（真实世界）</strong></mark>：模拟真实漏洞利用，比如攻击物联网设备。</p>\n<p>​\t<em><strong>* 战争分享模式 *</strong></em>：队伍互相出题 + 解题 + 分享思路，综合评分。</p>\n<p>​\t<em><strong>*AI 自动化（RHG）*</strong></em>：编写自动化程序（bot）全自动挖掘漏洞并提交 flag。</p>\n<h3 id=\"ctf主要题型及考察重点\"><a class=\"anchor\" href=\"#ctf主要题型及考察重点\">❡</a> CTF 主要题型及考察重点</h3>\n<p>&lt;!–code￼0–&gt;</p>\n<h3 id=\"ctf学习路线\"><a class=\"anchor\" href=\"#ctf学习路线\">❡</a> CTF 学习路线</h3>\n<ol>\n<li>\n<p>初期基础</p>\n<p><em><strong>*Web 开发 *</strong></em>：HTML/CSS/JS、PHP+MySQL 开发动态网站，掌握基础漏洞原理（如 SQL 注入）。</p>\n<p><em><strong>* 工具入门 *</strong></em>：Burp Suite 抓包改包、Python 脚本编写（requests 库）。</p>\n</li>\n<li>\n<p>中期漏洞专项</p>\n<p><em><strong>* 核心漏洞 *</strong></em>：SQL 注入、文件上传、命令执行（RCE）、XSS/CSRF。</p>\n<p><em><strong>* 靶场练习 *</strong></em>：sqli-labs、upload-labs、DVWA。</p>\n</li>\n<li>\n<p>后期综合实战</p>\n<p><em><strong>* 赛事参与 *</strong></em>：BUUCTF、CTFHub 等平台刷题，参与校赛 / XCTF 联赛。</p>\n<p><em><strong>* 知识扩展 *</strong></em>：逆向工程（《加密与解密》）、二进制漏洞（《IDA Pro 权威指南》）。</p>\n</li>\n</ol>\n<h3 id=\"比赛形式\"><a class=\"anchor\" href=\"#比赛形式\">❡</a> 比赛形式</h3>\n<p>CTF 比赛一般分为线上赛和线下赛。通常来说，线上赛多为 <code>初赛</code> ，线下赛多为 <code>决赛</code> ，但是也不排除直接进行</p>\n<h4 id=\"线上\"><a class=\"anchor\" href=\"#线上\">❡</a> 线上</h4>\n<p>选手通过主办方搭建的比赛平台在线注册，在线做题并提交 flag，线上比赛多为解题模式，攻防模式较为少见。通常来说对于长时间未解出的题目，主办方会酌情给出 == 提示 ( <code>Hint</code> )== 来帮助选手做题。</p>\n<h4 id=\"线下\"><a class=\"anchor\" href=\"#线下\">❡</a> 线下</h4>\n<p>选手前往比赛所在地，现场接入比赛网络进行比赛，<mark>线下多为 AWD 模式</mark>，近年来随着比赛赛制的不断革新，线下赛也会出现多种模式混合进行，例如<mark>结合<strong>解题 + AWD</strong> ，<strong>解题 + RW</strong></mark> 等等</p>\n<h3 id=\"题目类型\"><a class=\"anchor\" href=\"#题目类型\">❡</a> 题目类型</h3>\n<p>​\t在 CTF 中主要包含以下 5 个大类的题目，有些比赛会根据自己的侧重点单独添加某个分类，例如 == <code>移动设备(Mobile)</code> ,  <code>电子取证(Forensics)</code> == 等，近年来也会出来混合类型的题目，例如在 Web 中存在一个二进制程序，需要选手先利用 Web 的漏洞获取到二进制程序，之后通过逆向或是 Pwn 等方式获得最终 flag</p>\n<h4 id=\"web\"><a class=\"anchor\" href=\"#web\">❡</a> Web</h4>\n<p>​\tWeb 类题目大部分情况下和网、Web、HTTP 等相关技能有关。主要考察选手对于 Web 攻防的一些知识技巧。诸如 == <code>SQL注入</code> 、 <code>XSS</code> 、 <code>代码执行</code> 、 <code>代码审计</code>  == 等等都是很常见的考点。一般情况下 Web 题目只会给出一个能够访问的 URL。部分题目会给出附件</p>\n<h4 id=\"pwn\"><a class=\"anchor\" href=\"#pwn\">❡</a> Pwn</h4>\n<p>​\tPwn 类题目重点考察选手对于 == <code>二进制漏洞的挖掘和利用</code> <mark>能力，其考点也通常在</mark> <code>堆栈溢出</code> 、 <code>格式化漏洞</code> 、 <code>UAF</code> 、 <code>Double Free</code> == 等常见二进制漏洞上。选手需要根据题目中给出的二进制可执行文件进行逆向分析，找出其中的漏洞并进行利用，编写对应的漏洞攻击脚本 ( <code>Exploit</code> )，进而对主办方给出的远程服务器进行攻击并获取 flag 通常来说 Pwn 类题目给出的远程服务器信息为 <code>nc IP_ADDRESS PORT</code> ，例如 <code>nc 1.2.3.4 4567</code>  这种形式，表示在 <code>1.2.3.4</code>  这个 IP 的 <code>4567</code>  端口上运行了该题目</p>\n<h4 id=\"reverse\"><a class=\"anchor\" href=\"#reverse\">❡</a> Reverse</h4>\n<p>Re 类题目考察选手 <code>逆向工程</code> 能力。题目会给出一个<mark>可执行二进制文件</mark>，有些时候也可能是 Android 的 APK 安装包。选手需要逆向给出的程序，分析其程序工作原理。最终根据程序行为等获得 flag</p>\n<h4 id=\"crypto\"><a class=\"anchor\" href=\"#crypto\">❡</a> Crypto</h4>\n<p>​\tCrypto 类题目考察选手对 <code>密码学</code> 相关知识的了解程度，诸如 <code>RSA</code> 、 <code>AES</code> 、 <code>DES</code>  等都是密码学题目的常客。有些时候也会给出一个加密脚本和密文，根据加密流程逆推出明文。</p>\n<h4 id=\"misc\"><a class=\"anchor\" href=\"#misc\">❡</a> Misc</h4>\n<p>​\tMisc 意为杂项，即不包含在以上分类的题目都会放到这个分类。题目会给出一个附件。选手下载该附件进行分析，最终得出 flag。</p>\n<p>​\t常见的题型有图片隐写、视频隐写、文档隐写、流量分析、协议分析、游戏、IoT 相关等等。五花八门，种类繁多。</p>\n<h2 id=\"刷题网站\"><a class=\"anchor\" href=\"#刷题网站\">❡</a> 刷题网站</h2>\n<h3 id=\"ctfhub\"><a class=\"anchor\" href=\"#ctfhub\">❡</a> CTFHub</h3>\n<h4 id=\"misc-2\"><a class=\"anchor\" href=\"#misc-2\">❡</a> Misc</h4>\n<h5 id=\"流量分析\"><a class=\"anchor\" href=\"#流量分析\">❡</a> 流量分析</h5>\n<h6 id=\"数据库流量\"><a class=\"anchor\" href=\"#数据库流量\">❡</a> 数据库流量</h6>\n<ul>\n<li>\n<h5 id=\"mysql流量\"><a class=\"anchor\" href=\"#mysql流量\">❡</a> Mysql 流量</h5>\n</li>\n</ul>\n<p>服务端回一个 Response OK , 至此，登录验证就算是完成啦～</p>\n<p>后面客户端向服务端发起查询请求：</p>\n<pre><code>==select @@version_comment limit 1==\n</code></pre>\n<p>注意得选择<mark>分组字节流</mark>才行</p>\n<ul>\n<li>\n<h5 id=\"redis流量\"><a class=\"anchor\" href=\"#redis流量\">❡</a> Redis 流量</h5>\n</li>\n<li>\n<h5 id=\"mongodb流量\"><a class=\"anchor\" href=\"#mongodb流量\">❡</a> MongoDB 流量</h5>\n</li>\n</ul>\n<p>注意：搜索时要这样才行 ==ctfhub {== 不然找不到。</p>\n<h6 id=\"协议流量分析\"><a class=\"anchor\" href=\"#协议流量分析\">❡</a> 协议流量分析</h6>\n<ul>\n<li>ICMP-data</li>\n</ul>\n<p>注意：tshark - r 「xxx」 -Y 「相关筛选命令」 -T fields -e data &gt; xxx</p>\n<p><mark>关键参数</mark>：</p>\n<ul>\n<li>-Y 「icmp &amp;&amp; icmp.type==8」：过滤 ICMP 类型为 8（Echo Request）的包 。\n<ul>\n<li><mark>这边等于 0 和 8 都可以，8 代表请求包，0 代表应答包</mark></li>\n</ul>\n</li>\n<li>-T fields -e data：仅输出 data 字段的十六进制内容 。</li>\n<li>flag.txt：将结果重定向到文件。</li>\n</ul>\n<p>常见 CTF 题型分析<br />\n单向传输（Type 8）：<br />\nFlag 数据通过客户端发送的多个请求包传输（如每个包携带一个字符）。</p>\n<p>​\t\t解法：过滤 Type 8 并提取 data。<br />\n​\t双向传输（Type 8 + Type 0）：<br />\n​\t\tFlag 可能分散在请求和响应包中（需同时分析两者）。</p>\n<p>​\t\t解法：过滤 icmp（不限制 Type），再根据包方向（ip.src/ip.dst）分类处理。</p>\n<p>​\t隐蔽回传（Type 0）：<br />\n​\t\t恶意程序通过响应包将敏感数据回传给攻击者（如数据外泄）。</p>\n<p>​\t\t解法：过滤 Type 0 并提取 data。</p>\n<p><mark><strong>总结</strong></mark></p>\n<ul>\n<li><strong>Type 8 vs Type 0</strong>：取决于 Flag 数据的<strong>传输方向</strong>（谁发送的包）。</li>\n<li><strong>CTF 经验法则</strong>： 如果题目提示 “客户端发送了异常 Ping 包”，优先用 <code>Type 8</code> ；若提示 “服务器返回了异常应答”，则用 <code>Type 0</code> 。</li>\n</ul>\n<p>python 代码</p>\n<p>&lt;!–code￼1–&gt;</p>\n<ul>\n<li>ICMP-Length</li>\n</ul>\n<p>&lt;!–code￼2–&gt;</p>\n<h4 id=\"彩蛋\"><a class=\"anchor\" href=\"#彩蛋\">❡</a> 彩蛋</h4>\n<h5 id=\"首页\"><a class=\"anchor\" href=\"#首页\">❡</a> 首页</h5>\n<p>在 FuzzDomain 工具中，{fuzz}.ctfhub.com 的设计核心是自动化生成测试目标。具体来说：</p>\n<ul>\n<li>动态占位符作用\n<ul>\n<li><mark>{fuzz} 是一个动态替换标记，相当于批量操作的 &quot;通配符&quot;</mark>。工具会从您指定的字典文件（图中路径 Dicwww.txt）中逐行读取内容，将每一行文字替换到 {fuzz} 的位置，<span class=\"exturl\" data-url=\"aHR0cDovL3huLS13d3ctZW84ZXExOWFueTJhLmN0Zmh1Yi5jb20=\">生成如 www.ctfhub.com</span>、api.ctfhub.com 等完整域名进行探测。</li>\n</ul>\n</li>\n<li>安全测试实战场景\n<ul>\n<li>这种设计特别适用于 CTF 竞赛 / 渗透测试中：假设攻击者想找出目标网站（<span class=\"exturl\" data-url=\"aHR0cDovL3huLS1jdGZodWItaGg0ay5jb20=\">如 ctfhub.com</span>）隐藏的子域名，但无法穷举所有可能性。通过加载包含常见子域名字段的字典（如 admin、test、dev 等），工具可自动化生成并验证数千种组合，快速定位有效域名。</li>\n</ul>\n</li>\n<li>扩展性设计\n<ul>\n<li>界面下方的字符规则 pqrstuvwxyz0123456789 Min 1 Max 3 表明：除了使用预设字典，工具还支持按字符规则自动生成测试内容。例如当勾选该规则时，会自动生成 1-3 位包含指定字符的随机组合（如 p1、2qr 等），与 {fuzz} 配合实现双重探测策略。</li>\n</ul>\n</li>\n</ul>\n<p>这种 {占位符}+ 字典 / 规则的组合方式，在保证测试覆盖率的同时大幅提升效率，是网络安全工具中常见的设计范式</p>\n<p>&lt;!–code￼3–&gt;</p>\n<h5 id=\"彩蛋-2\"><a class=\"anchor\" href=\"#彩蛋-2\">❡</a> 彩蛋</h5>\n<h5 id=\"题目入口该题需要之前的题目提交flag后不关闭环境但是我这边提交后自动关闭环境没有办法实现\"><a class=\"anchor\" href=\"#题目入口该题需要之前的题目提交flag后不关闭环境但是我这边提交后自动关闭环境没有办法实现\">❡</a> 题目入口（该题需要之前的题目提交 flag 后不关闭环境，但是我这边提交后自动关闭环境没有办法实现）</h5>\n<h5 id=\"writeup\"><a class=\"anchor\" href=\"#writeup\">❡</a> WriteUp</h5>\n<h5 id=\"工具\"><a class=\"anchor\" href=\"#工具\">❡</a> 工具</h5>\n<p>在 CTFHub 工具 页面翻到最后发现 egg</p>\n<h5 id=\"赛事\"><a class=\"anchor\" href=\"#赛事\">❡</a> 赛事</h5>\n<h5 id=\"真题\"><a class=\"anchor\" href=\"#真题\">❡</a> 真题</h5>\n<h5 id=\"投稿提交\"><a class=\"anchor\" href=\"#投稿提交\">❡</a> 投稿提交</h5>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2d1eW91bmcvQ2FwdGZFbmNvZGVyJUU2JTg4JTk2JUU4JTgwJTg1JUU0JUJEJUJGJUU3JTk0JUE4JUU5JTlBJThGJUU2JUIzJUEyJUU5JTgwJTkwJUU2JUI1JTgxJUU1JThEJUIzJUU1JThGJUFG\">https://github.com/guyoung/CaptfEncoder 或者使用随波逐流即可</span></p>\n<p>flag[36:42]：a5f3a8</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93cml0ZXVwLmN0Zmh1Yi5jb20vT3RoZXIvJUU2JThBJTk1JUU3JUE4JUJGJUU4JUFGJUI0JUU2JTk4JThFL2VhZWQzYWJkLmh0bWw=\">https://writeup.ctfhub.com/Other/ 投稿说明 /eaed3abd.html</span></p>\n<p><mark>AES 解密</mark>：<span class=\"exturl\" data-url=\"aHR0cDovL3Rvb2wuY2hhY3VvLm5ldC9jcnlwdGFlcw==\">http://tool.chacuo.net/cryptaes</span></p>\n<h4 id=\"web-2\"><a class=\"anchor\" href=\"#web-2\">❡</a> Web</h4>\n<h5 id=\"目录遍历\"><a class=\"anchor\" href=\"#目录遍历\">❡</a> 目录遍历</h5>\n<p>​\t<strong>知识点</strong></p>\n<p>​\t\t目录遍历是 web 中常见的基础操作，我们通常会通过目录的遍历来发现是否存在对我们有用的信息。</p>\n<h5 id=\"phpinfo\"><a class=\"anchor\" href=\"#phpinfo\">❡</a> PHPINFO</h5>\n<ul>\n<li>​\tPHPinfo：输出 PHP 当前状态的大量信息，包含了 PHP 编译选项、启用的扩展、PHP 版本、服务器信息和环境变量（如果编译为一个模块的话）、PHP 环境变量、操作系统版本信息、path 变量、配置选项的本地值和主值、HTTP 头和 PHP 授权信息 (License)。</li>\n<li>​\tphpinfo () 同时是个很有价值的、包含所有 EGPCS (Environment, GET, POST, Cookie, Server) 数据的调试工具。</li>\n</ul>\n<h5 id=\"备份文件下载\"><a class=\"anchor\" href=\"#备份文件下载\">❡</a> 备份文件下载</h5>\n<h6 id=\"网站源码\"><a class=\"anchor\" href=\"#网站源码\">❡</a> 网站源码</h6>\n<ul>\n<li><strong>知识点</strong>\n<ul>\n<li>常见的网站源码的文件名有：『web』, 『website』, 『backup』, 『back』, 『www』, 『wwwroot』, 'temp’等等。</li>\n<li>常见的网站源码备份文件后缀有：『tar』, 『tar.gz』, 『zip』, 'rar’等等。</li>\n</ul>\n</li>\n</ul>\n<p><mark>先使用 /www.zip 等给的不同来试，发现只有 /www.zip 有东西，而且直接打开还没有信息，只能网站打开才行</mark>。</p>\n<h6 id=\"bak文件\"><a class=\"anchor\" href=\"#bak文件\">❡</a> bak 文件</h6>\n<p>bak 文件泄露</p>\n<p>​\t有些时候网站管理员可能为了方便，会在修改某个文件的时候先复制一份，将其命名为 xxx.bak。而<mark>大部分 Web Server 对 bak 文件并不做任何处理，导致可以直接下载，从而获取到网站某个文件的源代码</mark></p>\n<p><mark>得加入 /index.php.bak 尤其是最后面的.bak 才行</mark></p>\n<h6 id=\"vim缓存\"><a class=\"anchor\" href=\"#vim缓存\">❡</a> vim 缓存</h6>\n<p>​\tvim 交换文件名</p>\n<ul>\n<li>在使用 vim 时会创建临时缓存文件，关闭 vim 时缓存文件则会被删除，当 vim 异常退出后，因为未处理缓存文件，导致可以通过缓存文件恢复原始文件内容</li>\n<li>以 index.php 为例：\n<ul>\n<li><mark>第一次产生的交换文件名为 .index.php.swp</mark></li>\n</ul>\n</li>\n<li>再次意外退出后，将会产生名为 <mark>.index.php.swo</mark> 的交换文件</li>\n<li>第三次产生的交换文件则为 <mark>.index.php.swn</mark></li>\n</ul>\n<p><mark>vim 一旦异常退出就会生成 swp 文件，且是隐藏文件</mark>。隐藏文件要加点，首页也说了 flag 在 index.php 源码中 所以 <mark>/.index.php.swp</mark> 直接下载。</p>\n<h6 id=\"ds_store\"><a class=\"anchor\" href=\"#ds_store\">❡</a> .DS_Store</h6>\n<ul>\n<li><mark>.DS_Store 是 Mac 下 Finder 用来保存如何展示文件 / 文件夹的数据文件，每个文件夹下对应一个</mark>。</li>\n<li>如果开发 / 设计人员将.DS_Store 上传部署到线上环境，可能造成文件目录结构泄漏，特别是备份文件、源代码文件。</li>\n<li>在发布代码时未删除文件夹中隐藏的.DS_store，被发现后，获取了敏感的文件名等信息。</li>\n</ul>\n<p><mark>下载后打开之后得用 linux 中的 cat 查看并且再用 URL 接着执行查看即可</mark>。</p>\n<h5 id=\"git泄露\"><a class=\"anchor\" href=\"#git泄露\">❡</a> Git 泄露</h5>\n<h3 id=\"buuctf\"><a class=\"anchor\" href=\"#buuctf\">❡</a> BUUCTF</h3>\n<h4 id=\"web-3\"><a class=\"anchor\" href=\"#web-3\">❡</a> Web</h4>\n<h5 id=\"极客大挑战-2019easysql\"><a class=\"anchor\" href=\"#极客大挑战-2019easysql\">❡</a> [极客大挑战 2019] EasySQL</h5>\n<h6 id=\"思路\"><a class=\"anchor\" href=\"#思路\">❡</a> 思路</h6>\n<p><strong>找输入点、试闭合符、构造万能密码</strong></p>\n<ol>\n<li>\n<p><strong>万能密码构造公式</strong></p>\n<p>&lt;!–code￼4–&gt;</p>\n</li>\n<li>\n<p><strong>进阶操作</strong> 若过滤了空格用 <code>/**/</code>  代替，过滤 <code>or</code>  用 <code>||</code>  连接符等</p>\n</li>\n<li>\n<p><strong>工具使用</strong> HackBar 直接修改 URL 参数发送请求（GET 传参用 <code>%23</code>  代替 <code>#</code> ）</p>\n</li>\n</ol>\n<h4 id=\"crypto-2\"><a class=\"anchor\" href=\"#crypto-2\">❡</a> Crypto</h4>\n<h5 id=\"一眼就解密\"><a class=\"anchor\" href=\"#一眼就解密\">❡</a> 一眼就解密</h5>\n<h5 id=\"md5\"><a class=\"anchor\" href=\"#md5\">❡</a> MD5</h5>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY21kNS5jb20v\">md5 在线解密破解，md5 解密加密</span></p>\n<h5 id=\"url编码\"><a class=\"anchor\" href=\"#url编码\">❡</a> Url 编码</h5>\n<h5 id=\"看我回旋踢\"><a class=\"anchor\" href=\"#看我回旋踢\">❡</a> 看我回旋踢</h5>\n<p><mark>synt=flag</mark></p>\n<h5 id=\"摩丝\"><a class=\"anchor\" href=\"#摩丝\">❡</a> 摩丝</h5>\n<h5 id=\"password一开始有点懵算是一种iq题\"><a class=\"anchor\" href=\"#password一开始有点懵算是一种iq题\">❡</a> password（一开始有点懵，算是一种 iq 题）</h5>\n<p>判断出是 10 个数，数字占 8 个，那么就从姓名缩写来看了</p>\n<h5 id=\"变异凯撒\"><a class=\"anchor\" href=\"#变异凯撒\">❡</a> 变异凯撒</h5>\n<p>​\t上面的 acsii 码值对比表可以看到 == 第一个字符向后移了 5,== 第二个向后移了 6, 第三个向后移了 7, 以此类推，很容易想到变异凯撒即每个向后移的位数是前一个加 1</p>\n<h5 id=\"quoted-printable\"><a class=\"anchor\" href=\"#quoted-printable\">❡</a> Quoted-printable</h5>\n<p>​\t<mark>Quoted-printable 将任何 8-bit 字节值可编码为 3 个字符：一个等号 &quot;=&quot; 后跟随两个十六进制数字 (0–9 或 A–F) 表示该字节的数值。</mark><br />\n​\t例如，ASCII 码换页符（十进制值为 12）可以表示为 &quot;=0C&quot;， 等号 &quot;=&quot;（十进制值为 61）必须表示为 &quot;=3D&quot;，gb2312 下 “中” 表示为 = D6=D0。除了可打印 ASCII 字符与换行符以外，所有字符必须表示为这种格式。</p>\n<p>原文链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pa2VDb2tlL2FydGljbGUvZGV0YWlscy8xMDU4NzczNzM=\">https://blog.csdn.net/MikeCoke/article/details/105877373</span></p>\n<h5 id=\"篱笆墙的影子\"><a class=\"anchor\" href=\"#篱笆墙的影子\">❡</a> 篱笆墙的影子</h5>\n<h5 id=\"rabbit\"><a class=\"anchor\" href=\"#rabbit\">❡</a> Rabbit</h5>\n<h5 id=\"rsa\"><a class=\"anchor\" href=\"#rsa\">❡</a> RSA</h5>\n<p>python 代码</p>\n<p>&lt;!–code￼5–&gt;</p>\n<h5 id=\"丢失的md5\"><a class=\"anchor\" href=\"#丢失的md5\">❡</a> 丢失的 MD5</h5>\n<p>python 代码</p>\n<p>&lt;!–code￼6–&gt;</p>\n<h5 id=\"alice与bob\"><a class=\"anchor\" href=\"#alice与bob\">❡</a> Alice 与 Bob</h5>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5qYjUxLm5ldC9qaXN1YW5xaS9mYWN0b3JfY2FsYw==\">在线分解质因数计算器工具 - 在线计算器 - 脚本之家在线工具</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5oaWVuY29kZS5jb20vaGFzaC5odG1s\">CTF 在线工具 - 哈希计算 | MD5、SHA1、SHA256、SHA384、SHA512、RIPEMD、RIPEMD160</span></p>\n<h5 id=\"大帝的密码武器\"><a class=\"anchor\" href=\"#大帝的密码武器\">❡</a> 大帝的密码武器</h5>\n<p>密文发现 C 为大写字母，而 C 移 13 位应该是大写 P，替换后，得到最终 flag。</p>\n<h5 id=\"rsarsa\"><a class=\"anchor\" href=\"#rsarsa\">❡</a> rsarsa</h5>\n<p>使用 RSA Tool2 工具解题</p>\n<p>python 代码</p>\n<p>&lt;!–code￼7–&gt;</p>\n<h5 id=\"windows系统密码\"><a class=\"anchor\" href=\"#windows系统密码\">❡</a> Windows 系统密码</h5>\n<p><mark>两个都用 Md5 试一下。</mark></p>\n<h5 id=\"信息化时代的步伐\"><a class=\"anchor\" href=\"#信息化时代的步伐\">❡</a> 信息化时代的步伐</h5>\n<p><mark>题目说结果为中文，结合 36（4x9）位的纯数字密文，猜测为中文电码解密。</mark></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucXF4aXV6aS5jbi9iaWFubWEvZGlhbmJhby5waHA=\">电报码在线翻译（国际摩尔斯电码及中文电码） - 千千秀字</span></p>\n<h5 id=\"凯撒替换呵呵\"><a class=\"anchor\" href=\"#凯撒替换呵呵\">❡</a> 凯撒？替换？呵呵！</h5>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9xdWlwcWl1cC5jb20v\">Quipqiup - Cryptoquip 和 Cryptogram 求解器</span></p>\n<p><img data-src=\"https://i-blog.csdnimg.cn/blog_migrate/fa5b30ef9a70de0a72aaf87bb44dc655.png\" alt=\"img\" /></p>\n<p><img data-src=\"https://i-blog.csdnimg.cn/blog_migrate/9a56f91a23107e16a1db6ddac5e7ea98.png\" alt=\"img\" /></p>\n<h5 id=\"萌萌哒的八戒\"><a class=\"anchor\" href=\"#萌萌哒的八戒\">❡</a> 萌萌哒的八戒</h5>\n<p>binwalk 然后猪圈密码即可</p>\n<h5 id=\"权限获得第一步\"><a class=\"anchor\" href=\"#权限获得第一步\">❡</a> 权限获得第一步</h5>\n<h4 id=\"misc-3\"><a class=\"anchor\" href=\"#misc-3\">❡</a> Misc</h4>\n<h5 id=\"金三胖\"><a class=\"anchor\" href=\"#金三胖\">❡</a> 金三胖</h5>\n<p>使用<mark>随波逐流、StegSolve-FrameBrower</mark></p>\n<h5 id=\"你竟然赶我走\"><a class=\"anchor\" href=\"#你竟然赶我走\">❡</a> 你竟然赶我走</h5>\n<p>使用<mark> strings、随波逐流、010Editor</mark> 方法</p>\n<h5 id=\"二维码\"><a class=\"anchor\" href=\"#二维码\">❡</a> 二维码</h5>\n<p>可以使用<mark> 010Editor 或者是 strings</mark> 进行查看，发现里面还有文件，所以采用了修改后缀名为 zip 发现有密码，或者使用 Binwalk 进行也可以，然后使用 archar 或者 ziperllo 进行爆破，出来密码即可。</p>\n<h5 id=\"大白\"><a class=\"anchor\" href=\"#大白\">❡</a> 大白</h5>\n<h6 id=\"python代码\"><a class=\"anchor\" href=\"#python代码\">❡</a> python 代码</h6>\n<p>&lt;!–code￼8–&gt;</p>\n<p>使用随波逐流或者<mark> 010Editor</mark> 进行修改宽高比</p>\n<h5 id=\"wireshark\"><a class=\"anchor\" href=\"#wireshark\">❡</a> wireshark</h5>\n<p><mark>http &amp;&amp; http.request.method == 「POST」</mark></p>\n<h6 id=\"分析图片信息\"><a class=\"anchor\" href=\"#分析图片信息\">❡</a> 分析图片信息</h6>\n<h5 id=\"乌镇峰会种图\"><a class=\"anchor\" href=\"#乌镇峰会种图\">❡</a> 乌镇峰会种图</h5>\n<p>strings 就行</p>\n<h5 id=\"n种方法解决\"><a class=\"anchor\" href=\"#n种方法解决\">❡</a> N 种方法解决</h5>\n<p>使用随波逐流工具</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly90aGUteC5jbi9lbmNvZGluZ3MvQmFzZTY0LmFzcHg=\">https://the-x.cn/encodings/Base64.aspx</span></p>\n<h5 id=\"基础破解\"><a class=\"anchor\" href=\"#基础破解\">❡</a> 基础破解</h5>\n<p>使用 archpr 工具即可，选数字</p>\n<h5 id=\"文件中的秘密\"><a class=\"anchor\" href=\"#文件中的秘密\">❡</a> 文件中的秘密</h5>\n<p><strong><span class=\"exturl\" data-url=\"aHR0cDovL3huLS1FWElGLWU3NmZ5MDlmLm9yZw==\">EXIF 信息.org</span></strong>:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9leGlmaW5mby5vcmc=\">https://exifinfo.org</span>](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9leGlmaW5mby5vcmcv\">https://exifinfo.org/</span></p>\n<h5 id=\"zip伪加密\"><a class=\"anchor\" href=\"#zip伪加密\">❡</a> zip 伪加密</h5>\n<p>&lt;!–code￼9–&gt;</p>\n<p><mark><strong>一找 PK 头，二看标志位，奇改偶，伪加密解除</strong></mark></p>\n<p><img data-src=\"https://i-blog.csdnimg.cn/direct/e0d9c37ffa4443cb8126d505954f1545.png\" alt=\"img\" /></p>\n<p>将 09 改为 00 即可</p>\n<h5 id=\"被嗅探的流量\"><a class=\"anchor\" href=\"#被嗅探的流量\">❡</a> 被嗅探的流量</h5>\n<h5 id=\"lsb\"><a class=\"anchor\" href=\"#lsb\">❡</a> LSB</h5>\n<p><mark><em>先单蓝后双红绿，三通道组合最后试</em></mark></p>\n<p><mark><em>Alpha 通道碰不得，藏密必选 RGB</em></mark></p>\n<h5 id=\"位平面选择原则三句黄金口诀\"><a class=\"anchor\" href=\"#位平面选择原则三句黄金口诀\">❡</a> 位平面选择原则（三句黄金口诀）</h5>\n<p><strong>口诀①</strong>：「LSB 隐写 0 位藏，9 成题目在此方」 <strong>口诀②</strong>：「红绿蓝三原色，同步勾选效率强」 <strong>口诀③</strong>：「高位平面先别慌，特殊变形才要防」</p>\n<ul>\n<li>\n<p><strong>为何只勾选 0 位？</strong> LSB 隐写本质是将数据藏在像素值二进制的最低位（第 0 位），如同把字写在纸的最边缘。 <em>示例</em>：像素值 <code>255</code>  的二进制是 <code>11111111</code> ，修改第 0 位后变为 <code>11111110</code> （差值仅 1，肉眼不可见）</p>\n</li>\n<li>\n<p><strong>什么情况要勾选 1/2 位？</strong> 当题目明确提示 &quot;高位隐写&quot; 或常规 0 位无结果时（约占 CTF 题 10%），按以下优先级排查：</p>\n<p>&lt;!–code￼10–&gt;</p>\n</li>\n</ul>\n<h5 id=\"rar\"><a class=\"anchor\" href=\"#rar\">❡</a> rar</h5>\n<p>使用 archpr 工具即可，选数字</p>\n<h5 id=\"qr\"><a class=\"anchor\" href=\"#qr\">❡</a> qr</h5>\n<p>使用 qr serach 工具扫一下即可</p>\n<h5 id=\"镜子里面的世界\"><a class=\"anchor\" href=\"#镜子里面的世界\">❡</a> 镜子里面的世界</h5>\n<p>使用 steg 里面的 dataexract 选择三个 0 即可</p>\n<p><img data-src=\"C:%5CUsers%5CHelloCTF_OS%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250414112403740.png\" alt=\"image-20250414112403740\" /></p>\n<h5 id=\"爱因斯坦\"><a class=\"anchor\" href=\"#爱因斯坦\">❡</a> 爱因斯坦</h5>\n<p><mark>binwalk -e 『/mnt/c/Users/HelloCTF_OS/Desktop/ 爱因斯坦 /misc2.jpg』</mark></p>\n<p>&lt;!–code￼11–&gt;</p>\n<h5 id=\"ningen\"><a class=\"anchor\" href=\"#ningen\">❡</a> ningen</h5>\n<h6 id=\"安装binwalk\"><a class=\"anchor\" href=\"#安装binwalk\">❡</a> 安装 Binwalk</h6>\n<p>&lt;!–code￼12–&gt;</p>\n<p>使用 BInwalk 提取，或者使用 010 删除前面保存 rar 然后密码破解即可</p>\n<h5 id=\"小明的保险箱\"><a class=\"anchor\" href=\"#小明的保险箱\">❡</a> 小明的保险箱</h5>\n<p><mark>通过 ff d9 发现 rar</mark></p>\n<h5 id=\"easycap\"><a class=\"anchor\" href=\"#easycap\">❡</a> easycap</h5>\n<p><mark>通过追踪流查看</mark></p>\n<h5 id=\"隐藏的钥匙\"><a class=\"anchor\" href=\"#隐藏的钥匙\">❡</a> 隐藏的钥匙</h5>\n<p>使用 strings 发现 flag 然后 Base64 解密即可</p>\n<h5 id=\"另外一个世界\"><a class=\"anchor\" href=\"#另外一个世界\">❡</a> 另外一个世界</h5>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucmFwaWR0YWJsZXMub3JnL3poLUNOL2NvbnZlcnQvbnVtYmVyL2FzY2lpLWhleC1iaW4tZGVjLWNvbnZlcnRlci5odG1s\">ASCII 文本，十六进制，二进制，十进制，Base64 转换器</span></p>\n<p>使用二进制解密即可</p>\n<p><img data-src=\"C:%5CUsers%5CHelloCTF_OS%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250414114853391.png\" alt=\"image-20250414114853391\" />s</p>\n<h5 id=\"数据包中的线索\"><a class=\"anchor\" href=\"#数据包中的线索\">❡</a> 数据包中的线索</h5>\n<p>通过追踪流发现有 = 号，判断可能是 base64, 但是过长考虑可能是图片转 base64 那么，需要通过网站并且添加头 ==“data:image/jpeg;base64,” 点击追加 img 标签 ==，</p>\n<p>图片在线转换 base64 编码 - 在线 base64 编码转换成图片工具 (<span class=\"exturl\" data-url=\"aHR0cDovL2pzb25zLmNu\">jsons.cn</span>)](<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5qc29ucy5jbi9pbWcyYmFzZTY0LyVFRiVCQyU4OQ==\">http://www.jsons.cn/img2base64/）</span></p>\n<h5 id=\"神秘龙卷风\"><a class=\"anchor\" href=\"#神秘龙卷风\">❡</a> 神秘龙卷风</h5>\n<p><mark>BrainFuck 解密</mark></p>\n<h5 id=\"flag\"><a class=\"anchor\" href=\"#flag\">❡</a> FLAG</h5>\n<p>使用 stegsolve 进行 rgb 查看，然后保存 1.zip, 因为是<mark> pk 开头</mark></p>\n<h5 id=\"假如给我三天光明\"><a class=\"anchor\" href=\"#假如给我三天光明\">❡</a> 假如给我三天光明</h5>\n<p>&lt;img src=「<span class=\"exturl\" data-url=\"aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvMTI5NDU4OC8yMDE3MTIvMTI5NDU4OC0yMDE3MTIwOTAyMDQxMDcxOC0yMDk3MTczOTI4LnBuZw==\">https://images2017.cnblogs.com/blog/1294588/201712/1294588-20171209020410718-2097173928.png</span>」 alt=「img」  /&gt;</p>\n<p>得到解压密码是<mark> kmdonowg</mark></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9tb3JzZWNvZGUud29ybGQvaW50ZXJuYXRpb25hbC9kZWNvZGVyL2F1ZGlvLWRlY29kZXItYWRhcHRpdmUuaHRtbA==\">Morse Code Audio Decoder</span></p>\n<p wpei08732?23dz=\"\">解码得：CTFWPEI08732?23D 换成 flag 还要换小写 flag</p>\n<h5 id=\"后门查杀\"><a class=\"anchor\" href=\"#后门查杀\">❡</a> 后门查杀</h5>\n<p>使用<mark> D 盾或者火绒安全</mark>进行查找然后再找到对应的文件查看即可</p>\n<h5 id=\"webshell后门少zp文件\"><a class=\"anchor\" href=\"#webshell后门少zp文件\">❡</a> webshell 后门 (少 zp 文件)</h5>\n<h5 id=\"来首歌吧\"><a class=\"anchor\" href=\"#来首歌吧\">❡</a> 来首歌吧</h5>\n<p>使用在线工具进行解密</p>\n<ol>\n<li>\n<p><strong>MorseFM</strong> <span class=\"exturl\" data-url=\"aHR0cHM6Ly9tb3JzZWZtLmNvbS8=\">https://morsefm.com/</span> （支持 WAV/MP3 等格式，支持多语言，适合快速解码）</p>\n</li>\n<li>\n<p><strong>Morse Code Magic</strong> <span class=\"exturl\" data-url=\"aHR0cHM6Ly9tb3JzZWNvZGVtYWdpYy5jb20vbW9yc2UtY29kZS1hdWRpby1kZWNvZGVyLw==\">https://morsecodemagic.com/morse-code-audio-decoder/</span> （专注 WAV/MP3 解码，4 分钟音频 5 秒完成）</p>\n</li>\n</ol>\n<h5 id=\"面具下的flag\"><a class=\"anchor\" href=\"#面具下的flag\">❡</a> 面具下的 flag</h5>\n<p>可以先用 strings 提取，但是需要对比两个找不同，发现少两个 + 号再解析不然出错</p>\n<h5 id=\"荷兰宽带数据泄露\"><a class=\"anchor\" href=\"#荷兰宽带数据泄露\">❡</a> 荷兰宽带数据泄露</h5>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubmlyc29mdC5uZXQv\">NirSoft - freeware utilities: password recovery, system utilities, desktop utilities</span></p>\n<p>搜索 username 或者 password，这可能是一个<mark>路由器配置文件 (bin)</mark>，所以用到 RouterPassView 软件</p>\n<h5 id=\"九连环\"><a class=\"anchor\" href=\"#九连环\">❡</a> 九连环</h5>\n<p>通过随波逐流发现有伪加密，所以搜索 50 4B 01 02 修改</p>\n<p><mark>安装命令</mark>：sudo apt update &amp;&amp; sudo apt install steghide</p>\n<p><mark>执行命令</mark>:steghide extract -sf 『/mnt/c/Users/HelloCTF_OS/Desktop/389a0c11-d0df-4180-829a-b529e6b0a1bc/_123456cry.jpg.extracted/asd/good - 已合并.jpg』</p>\n<h5 id=\"认真你就输了\"><a class=\"anchor\" href=\"#认真你就输了\">❡</a> 认真你就输了</h5>\n<p>随波逐流发现文件头是 zip 文件，要么修改文件要么 binwalk 就行</p>\n<h5 id=\"被偷走的文件\"><a class=\"anchor\" href=\"#被偷走的文件\">❡</a> 被偷走的文件</h5>\n<p>pcap 文件用 wireshark 并且发现 ftp-data 有 rar 文件进行到处对象导出即可。</p>\n<p><mark>导出文件三种方法：</mark></p>\n<ol>\n<li>到处对象</li>\n<li>追踪流然后原始数据导出即可</li>\n<li>导出字节流</li>\n</ol>\n<h5 id=\"被劫持的神秘礼物\"><a class=\"anchor\" href=\"#被劫持的神秘礼物\">❡</a> 被劫持的神秘礼物</h5>\n<p>使用 wireshark 发现 ==(application/x-www-form-urlencoded)==，之后根据题意找到账号密码拼接，使用如下命令即可。</p>\n<p>&lt;!–code￼13–&gt;</p>\n<h5 id=\"藏藏藏\"><a class=\"anchor\" href=\"#藏藏藏\">❡</a> 藏藏藏</h5>\n<p>打开 010 发现 pk 删除前面所有内容保存 zip 解压后扫码即可</p>\n<h5 id=\"佛系青年\"><a class=\"anchor\" href=\"#佛系青年\">❡</a> 佛系青年</h5>\n<p>伪加密修改后查看 fo.txt 底下那句话使用随波逐流解密即可</p>\n<h5 id=\"你猜我是个啥\"><a class=\"anchor\" href=\"#你猜我是个啥\">❡</a> 你猜我是个啥</h5>\n<p>使用 strings 查看即可</p>\n<h5 id=\"秘密文件\"><a class=\"anchor\" href=\"#秘密文件\">❡</a> 秘密文件</h5>\n<p>筛选后发现有<mark> ftp 优先查看</mark>，发现里面有 rar 文件，还有一点其实随波逐流里面也可以直接查看并且通过分离破解即可获取 flag.</p>\n<h5 id=\"刷新过的图片\"><a class=\"anchor\" href=\"#刷新过的图片\">❡</a> 刷新过的图片</h5>\n<p>&lt;!–code￼14–&gt;</p>\n<p>题目说 “刷新过的图片”，结合键盘上刷新键为 F5 可判断此题为 F5 隐写，运用工具<mark> F5-steganography</mark> 可以对其中的内容进行提取</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRjb2RlLmNvbS9naF9taXJyb3JzL2Y1L0Y1LXN0ZWdhbm9ncmFwaHk/dXRtX3NvdXJjZT1jc2RuX2dpdGh1Yl9hY2NlbGVyYXRvciZhbXA7aXNMb2dpbj0x\">项目首页 - F5-steganography:F5 steganography - GitCode</span></p>\n<p>cd F5-steganography-master</p>\n<p>java Extract 『/mnt/c/Use<br />\nrs/HelloCTF_OS/Desktop/a05ed035-b476-49d6-9b32-462ff13c5944/Misc.jpg』</p>\n<h5 id=\"鸡你太美\"><a class=\"anchor\" href=\"#鸡你太美\">❡</a> 鸡你太美</h5>\n<p>发现缺少 gif 头，<mark>47 49 46 38</mark>.</p>\n<h5 id=\"just_a_rar\"><a class=\"anchor\" href=\"#just_a_rar\">❡</a> just_a_rar</h5>\n<p>破解密码然后查看 exif 信息即可</p>\n<h5 id=\"snake原先的网站没有了所以解析不了\"><a class=\"anchor\" href=\"#snake原先的网站没有了所以解析不了\">❡</a> snake (原先的网站没有了，所以解析不了)</h5>\n<p>&lt;!–code￼15–&gt;</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3NlcnBlbnQub25saW5lLWRvbWFpbi10b29scy5jb20v\">Serpent Encryption – Easily encrypt or decrypt strings or files</span></p>\n<p>&lt;img src=「<span class=\"exturl\" data-url=\"aHR0cHM6Ly9pLWJsb2cuY3NkbmltZy5jbi9ibG9nX21pZ3JhdGUvNTkzYmU3NmQwMzhkZmVjZTBmY2VlMGVkMDUyMDU2MWEucG5n\">https://i-blog.csdnimg.cn/blog_migrate/593be76d038dfece0fcee0ed0520561a.png</span>」 alt=「img」 style=「zoom:50%;」 /&gt;</p>\n<h5 id=\"菜刀666\"><a class=\"anchor\" href=\"#菜刀666\">❡</a> 菜刀 666</h5>\n<p>菜刀使用 http.request.method<mark>POST，并且查看 z1 和 z2，发现 z2 有 FF D8 是 jpg 导入 010 发现密码</mark>，然后解压即可</p>\n<h5 id=\"一叶障目\"><a class=\"anchor\" href=\"#一叶障目\">❡</a> 一叶障目</h5>\n<p>可以使用之前的 Python 脚本或者随波逐流即可</p>\n<h5 id=\"纳尼\"><a class=\"anchor\" href=\"#纳尼\">❡</a> 纳尼</h5>\n<p>如果 git 分帧查看不了，那么就用<mark> stegsolve 的 framebrower</mark> 来查看即可。</p>\n<h5 id=\"神奇的二维码\"><a class=\"anchor\" href=\"#神奇的二维码\">❡</a> 神奇的二维码</h5>\n<p>Python 代码</p>\n<p>&lt;!–code￼16–&gt;</p>\n<p><mark>粗线条是 <code>-</code> , 细线条是 <code>.</code> </mark></p>\n<h5 id=\"excel破解\"><a class=\"anchor\" href=\"#excel破解\">❡</a> excel 破解</h5>\n<p>使用 strings 或者随波逐流查看即可</p>\n<h5 id=\"来题中等的吧\"><a class=\"anchor\" href=\"#来题中等的吧\">❡</a> 来题中等的吧</h5>\n<p>粗细记录摩斯密码即可</p>\n<h5 id=\"谁赢了比赛\"><a class=\"anchor\" href=\"#谁赢了比赛\">❡</a> 谁赢了比赛？</h5>\n<p>使用 Binwalk 进行分离并且破解密码，之后使用 qcr 进行二维码解析</p>\n<h5 id=\"actf新生赛2020outguess\"><a class=\"anchor\" href=\"#actf新生赛2020outguess\">❡</a> [ACTF 新生赛 2020] outguess</h5>\n<p>发现 exif 再通过社会主义解密，然后通过题目猜测发现是 outguess，通过一下密码解密</p>\n<p>&lt;!–code￼17–&gt;</p>\n<p><mark>outguess -k 『abc』 -r 『/mnt/c/Users/HelloCTF_OS/Desktop/attachment/tmp/huhuhu/mmm.jpg』 『/mnt/c/Users/HelloCTF_OS/Desktop/attachment/tmp/huhuhu/flag.txt』</mark></p>\n<h5 id=\"梅花香之苦寒来\"><a class=\"anchor\" href=\"#梅花香之苦寒来\">❡</a> 梅花香之苦寒来</h5>\n<p>使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT1nbnVwbG90JmFtcDtzcG09MTAwMS4yMTAxLjMwMDEuNzAyMA==\"> gnuplot</span> 画图即可</p>\n<p>生成文本后使用 plot xxx.</p>\n<p>python 代码</p>\n<p>&lt;!–code￼18–&gt;</p>\n<h5 id=\"wustctf2020find_me在线网站打不开\"><a class=\"anchor\" href=\"#wustctf2020find_me在线网站打不开\">❡</a> [WUSTCTF2020] find_me（在线网站打不开）</h5>\n<p>使用 exiftool xxx，然后<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucXF4aXV6aS5jbi9iaWFubWEvd2VuYmVuamlhbWkucGhwP3M9bWFuZ3dlbg==\">盲文在线加解密：https://www.qqxiuzi.cn/bianma/wenbenjiami.php?s=mangwen</span></p>\n<p>&lt;!–code￼19–&gt;</p>\n<p><img data-src=\"https://i-blog.csdnimg.cn/blog_migrate/4ff6c936f2b993b6adf9ed29d0f06748.png#pic_center\" alt=\"img\" /></p>\n<h5 id=\"穿越时空的思念\"><a class=\"anchor\" href=\"#穿越时空的思念\">❡</a> 穿越时空的思念</h5>\n<p>之前使用静音删除左声道，单声道导出右声道 wav 使用在线网站但是解析有些许错误，所以使用手动解析</p>\n<h5 id=\"guet-ctf2019ko\"><a class=\"anchor\" href=\"#guet-ctf2019ko\">❡</a> [GUET-CTF2019]KO</h5>\n<p>使用 brainfuck 解密即可</p>\n<h5 id=\"actf新生赛2020base64隐写\"><a class=\"anchor\" href=\"#actf新生赛2020base64隐写\">❡</a> [ACTF 新生赛 2020] base64 隐写</h5>\n<p>python 代码</p>\n<p>&lt;!–code￼20–&gt;</p>\n<h5 id=\"swpu2019我有一只马里奥\"><a class=\"anchor\" href=\"#swpu2019我有一只马里奥\">❡</a> [SWPU2019] 我有一只马里奥</h5>\n<p><img data-src=\"https://i-blog.csdnimg.cn/blog_migrate/470b5a3cf4221c8ae78e537ab080d524.jpeg\" alt=\"img\" /></p>\n<p><img data-src=\"https://i-blog.csdnimg.cn/blog_migrate/227814f4d8ae4900b77417b09ad5b617.png\" alt=\"img\" /></p>\n<p><mark>notepad 1.txt:flag.txt</mark></p>\n<p>使用工具 NtfsStreamsEditor 或 AlternateStreamView 打开存放 1.txt 文件的文件夹，扫描出现隐藏文件文件，导出后打开，得到 flag。</p>\n<p>​\t\t<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubmlyc29mdC5uZXQvdXRpbHMvYWx0ZXJuYXRlX2RhdGFfc3RyZWFtcy5odG1sP3NwbT1hMmM2aC4xMjg3MzYzOS5hcnRpY2xlLWRldGFpbC42LjY5YWU0MjQ1UkIyQ2pL\">AlternateStreamView (跳转页面后，向下滑动，下载对应的 32 或 64 位软件)</span></p>\n<h5 id=\"mrctf2020ezmisc\"><a class=\"anchor\" href=\"#mrctf2020ezmisc\">❡</a> [MRCTF2020]ezmisc</h5>\n<p>修改宽高</p>\n<h5 id=\"gxyctf2019gakki\"><a class=\"anchor\" href=\"#gxyctf2019gakki\">❡</a> [GXYCTF2019]gakki</h5>\n<p>python 代码</p>\n<p>&lt;!–code￼21–&gt;</p>\n<h5 id=\"hbnis218caesar\"><a class=\"anchor\" href=\"#hbnis218caesar\">❡</a> [HBNIS218]caesar</h5>\n<p>python 代码</p>\n<p>&lt;!–code￼22–&gt;</p>\n<p>随波逐流</p>\n<h5 id=\"suctf2018single-dog\"><a class=\"anchor\" href=\"#suctf2018single-dog\">❡</a> [SUCTF2018]single dog</h5>\n<p><mark>aaencode 编码</mark></p>\n<h5 id=\"黑客帝国\"><a class=\"anchor\" href=\"#黑客帝国\">❡</a> 黑客帝国</h5>\n<p>导入十六进制，然后发现打开不了，换成 jpg 头，也就是<mark> FF D8 4A46</mark> 之前的删除掉</p>\n<h5 id=\"hbnis2018低个头\"><a class=\"anchor\" href=\"#hbnis2018低个头\">❡</a> [HBNIS2018] 低个头</h5>\n<p>键盘按键</p>\n<h5 id=\"swpu2019伟大的侦探\"><a class=\"anchor\" href=\"#swpu2019伟大的侦探\">❡</a> [SWPU2019] 伟大的侦探</h5>\n<p><mark>使用 010 Editor 打开密码.txt 文件，选择编辑方式为 EBCDIC (B)，找到明文密码</mark></p>\n<p>之后对照跳舞的小人即可</p>\n<p>[BUUCTF <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzE0MDQxMjQ=\">SWPU2019] 伟大的侦探 1 - 阿里云开发者社区</span></p>\n<h5 id=\"mrctf2020你能看懂音符吗\"><a class=\"anchor\" href=\"#mrctf2020你能看懂音符吗\">❡</a> [MRCTF2020] 你能看懂音符吗</h5>\n<p>修改 62 51 为 51 62 然后保存解压，之后发现 Binwalk 有文件，之后 document.xml 里查到音符，使用芊芊秀字（但是失效了）就可以了。</p>\n<h5 id=\"我吃三明治\"><a class=\"anchor\" href=\"#我吃三明治\">❡</a> 我吃三明治</h5>\n<p><mark>foremost -i /mnt/c/Users/HelloCTF_OS/Desktop/attachment/flag.jpg</mark>, 发现有两张图片，但是打开还是之前的那张，通过题解发现 FF D8 是开头，FF D9 是结尾，在 FF D8 和 FF D9 之间有信息。</p>\n<p><img data-src=\"C:%5CUsers%5CHelloCTF_OS%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250414132629896.png\" alt=\"image-20250414132629896\" /></p>\n<h5 id=\"actf新生赛2020ntfs数据流\"><a class=\"anchor\" href=\"#actf新生赛2020ntfs数据流\">❡</a> [ACTF 新生赛 2020] NTFS 数据流</h5>\n<p>跟之前的一道题类似使用 alternatestreamview-x64 打开文件在导出即可。</p>\n<h5 id=\"swpu2019你有没有好好看网课\"><a class=\"anchor\" href=\"#swpu2019你有没有好好看网课\">❡</a> [SWPU2019] 你有没有好好看网课？</h5>\n<p>使用数字发现四位不够，一位位加到 6 位即可，</p>\n<p>&lt;img src=「C:\\Users\\HelloCTF_OS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250414133454939.png」 alt=「image-20250414133454939」 style=「zoom:50%;」 /&gt;</p>\n<p><mark>使用 kinovea 软件，根据图片说的 5.20 和 7.11 其实是 5.67 左右在灯上出现内容</mark>，然后第一处为敲击码</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5oaWVuY29kZS5jb20vdGFwY29kZS5odG1s\">CTF 在线工具 - 在线敲击码 | 敲击码编码 | 敲击码算法 | tap code</span></p>\n<p>基于 5×5 方格波利比奥斯方阵来实现的，不同点是是用 K 字母被整合到 C 中，因此密文的特征为 1-5 的两位一组的数字，编码的范围是 A-Z 字母字符集，字母不区分大小写。<br />\n <code>..... ../... ./... ./... ../</code></p>\n<p><strong>解码方法</strong>： 每组  <code>/</code>  分隔的符号对应一个字母，例如：</p>\n<ul>\n<li><mark> <code>..... ..</code>  → 第 5 行第 2 列 → <strong>W</strong></mark></li>\n<li><code>... .</code>  → 第 3 行第 1 列 → <strong>L</strong></li>\n<li>完整密文  <code>WLLM</code>  → 转为小写  <code>wllm</code></li>\n</ul>\n<p><img data-src=\"https://cdn.nlark.com/yuque/0/2023/png/8395640/1675319712830-f36e439d-6d04-46cb-8e6f-2b00729fdbd2.png#averageHue=%23e8e8e8&amp;clientId=uf8fd4f20-b975-4&amp;from=drop&amp;id=uec020910&amp;name=vta8io4tvs.png&amp;originHeight=281&amp;originWidth=331&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=13988&amp;status=done&amp;style=none&amp;taskId=u3aae15bd-604d-484b-ae31-ce85fd125dd&amp;title=\" alt=\"vta8io4tvs.png\" /></p>\n<p>&lt;img src=「C:\\Users\\HelloCTF_OS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250414230545542.png」 alt=「image-20250414230545542」 style=「zoom:50%;」 /&gt;</p>\n<p>&lt;img src=「C:\\Users\\HelloCTF_OS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250414135800024.png」 alt=「image-20250414135800024」 style=「zoom:50%;」 /&gt;</p>\n<p>也可以通过 52313132 来解码，就是数点即可。</p>\n<p>&lt;img src=「C:\\Users\\HelloCTF_OS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250414230944212.png」 alt=「image-20250414230944212」 style=「zoom:50%;」 /&gt;</p>\n<p><mark>然后根据 7.37 时候发现编码</mark></p>\n<p><img data-src=\"C:%5CUsers%5CHelloCTF_OS%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250414230821026.png\" alt=\"image-20250414230821026\" /></p>\n<p>&lt;img src=「C:\\Users\\HelloCTF_OS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250414231107859.png」 alt=「image-20250414231107859」 style=「zoom:50%;」 /&gt;</p>\n<p>之后拼接起来两个解码信息进行解压，然后使用 strings 或者随波逐流即可查看信息.</p>\n<p>扩展知识：</p>\n<p>​\t查询多个信息</p>\n<p>​\t\t逻辑或</p>\n<p>​\t \t\tstrings xxx | grep -iE 「flag|ctf」</p>\n<ul>\n<li><code>-i</code> ：忽略大小写</li>\n<li><mark> <code>-E</code> ：启用扩展正则表达式，允许使用  <code>|</code>  符号分隔多个模式</mark></li>\n</ul>\n<p>​\t\t逻辑与</p>\n<p>​\t\t\tstrings xxx | grep -i 「flag」 | grep -i 「ctf」</p>\n<p>​\t\t<strong>查找并显示头尾匹配结果</strong></p>\n<p>&lt;!–code￼23–&gt;</p>\n<p>​\t<strong>结合十六进制查看工具</strong> 如果需要分析二进制文件的特定偏移：</p>\n<p>&lt;!–code￼24–&gt;</p>\n<p><mark>xxd：生成十六进制和 ASCII 表示</mark><br />\n<mark> hexdump -C：经典格式的十六进制转储</mark></p>\n<h5 id=\"sqltest\"><a class=\"anchor\" href=\"#sqltest\">❡</a> sqltest</h5>\n<p>&lt;!–code￼25–&gt;</p>\n<p>python 代码</p>\n<p>&lt;!–code￼26–&gt;</p>\n<h5 id=\"utctf2020docx\"><a class=\"anchor\" href=\"#utctf2020docx\">❡</a> [UTCTF2020]docx</h5>\n<p>进行 Binwalk 然后再 media 一张张图 png 查看信息</p>\n<p>&lt;img src=「C:\\Users\\HelloCTF_OS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250415005201083.png」 alt=「image-20250415005201083」 style=「zoom:50%;」 /&gt;</p>\n<h5 id=\"john-in-the-middle\"><a class=\"anchor\" href=\"#john-in-the-middle\">❡</a> john-in-the-middle</h5>\n<p>先用导出对象发现很多图片，逐个使用 stegsolve 发现有信息</p>\n<p>&lt;img src=「C:\\Users\\HelloCTF_OS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250415010713381.png」 alt=「image-20250415010713381」 style=「zoom:50%;」 /&gt;</p>\n<p>扩展知识：</p>\n<p>​\t<strong>zsteg 功能</strong>：<mark>支持 LSB 隐写</mark>、zlib 压缩数据、OpenStego 等检测，常用于 CTF 比赛的图片隐写分析</p>\n<p>&lt;!–code￼27–&gt;</p>\n<h5 id=\"actf新生赛2020swp\"><a class=\"anchor\" href=\"#actf新生赛2020swp\">❡</a> [ACTF 新生赛 2020] swp</h5>\n<p>发现 zip 文件导出然后使用 strings 查看即可</p>\n<h5 id=\"gxyctf2019sxmgdghpcybiyxnlpw\"><a class=\"anchor\" href=\"#gxyctf2019sxmgdghpcybiyxnlpw\">❡</a> [GXYCTF2019]SXMgdGhpcyBiYXNlPw==</h5>\n<p>python 代码</p>\n<p>&lt;!–code￼28–&gt;</p>\n<h5 id=\"间谍启示录\"><a class=\"anchor\" href=\"#间谍启示录\">❡</a> 间谍启示录</h5>\n<p>使用 foremost 然后用 tree 发现文件，<mark>重要的是开启隐藏的文件</mark>，机密文件查看即可。</p>\n<p>&lt;img src=「C:\\Users\\HelloCTF_OS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250415014559922.png」 alt=「image-20250415014559922」 style=「zoom:50%;」 /&gt;</p>\n<h5 id=\"小易的u盘\"><a class=\"anchor\" href=\"#小易的u盘\">❡</a> 小易的 U 盘</h5>\n<p>使用修改后缀名或者是 foremost 查看，然后根据 strings 或者使用 IDA 查看也行。</p>\n<p>&lt;!–code￼29–&gt;</p>\n<p><img data-src=\"C:%5CUsers%5CHelloCTF_OS%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250415015843942.png\" alt=\"image-20250415015843942\" /></p>\n<p>&lt;img src=「C:\\Users\\HelloCTF_OS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250415015624829.png」 alt=「image-20250415015624829」 style=「zoom:50%;」 /&gt;</p>\n<h5 id=\"喵喵喵\"><a class=\"anchor\" href=\"#喵喵喵\">❡</a> 喵喵喵</h5>\n<p>使用 zsteg 查看然后使用 stegsolve 进行 lsb 隐写保存图片之后修改宽高，使用 QR 进行查看链接下载，<mark>注意的是得用 winrar 解压才行</mark>，不然 NTFS 查看不到，然后使用 pyc 反编译，使用脚本。</p>\n<p>pyc 反编译：<span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29sLmx1L3B5Yy8=\">https://tool.lu/pyc/</span></p>\n<p>python 代码</p>\n<p>&lt;!–code￼30–&gt;</p>\n<h5 id=\"wustctf2020爬\"><a class=\"anchor\" href=\"#wustctf2020爬\">❡</a> [WUSTCTF2020] 爬</h5>\n<p>使用 file 文件查看后缀名，然后转换 word 删除图片，<mark>使用十六进制转字符查看即可</mark>。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmVqc29uLmNvbS9jb252ZXJ0L294MnN0ci8=\">https://www.bejson.com/convert/ox2str/</span></p>\n",
            "tags": [
                "网络安全",
                "CTF学习"
            ]
        },
        {
            "id": "http://whw-colab.github.io/2025/04/17/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E8%AF%AD%E6%B3%95%E7%AF%87/",
            "url": "http://whw-colab.github.io/2025/04/17/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E8%AF%AD%E6%B3%95%E7%AF%87/",
            "title": "C#学习笔记——语法篇",
            "date_published": "2025-04-17T04:12:57.000Z",
            "content_html": "<h1 id=\"语法篇\"><a class=\"anchor\" href=\"#语法篇\">❡</a> 语法篇</h1>\n<h2 id=\"基础背景知识\"><a class=\"anchor\" href=\"#基础背景知识\">❡</a> 基础背景知识</h2>\n<p>c# 编写的应用程序必须放置于.NET 环境中才能正常允许。C# 代码最终会被编译为 **” 中间语言 “（MSIL）**。</p>\n<p>类库是以.dll 结尾，不能直接运行，而启动项目是以.exe 结尾可以直接运行。</p>\n<p>&lt;!–code￼0–&gt;</p>\n<p>主项目也叫<strong>启动项目</strong>，可以通过该设置方式设置启动项目。</p>\n<p><img data-src=\"C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250112163340278.png\" alt=\"image-20250112163340278\" /></p>\n<h2 id=\"基本语法\"><a class=\"anchor\" href=\"#基本语法\">❡</a> <strong>基本语法</strong></h2>\n<h2 id=\"面向过程\"><a class=\"anchor\" href=\"#面向过程\">❡</a> <strong>面向过程</strong></h2>\n<h3 id=\"debug类\"><a class=\"anchor\" href=\"#debug类\">❡</a> Debug 类</h3>\n<p><img data-src=\"C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250111135001389.png\" alt=\"image-20250111135001389\" /></p>\n<p>&lt;!–code￼1–&gt;</p>\n<h3 id=\"变量与常量\"><a class=\"anchor\" href=\"#变量与常量\">❡</a> 变量与常量</h3>\n<p>&lt;!–code￼2–&gt;</p>\n<h3 id=\"注释\"><a class=\"anchor\" href=\"#注释\">❡</a> 注释</h3>\n<p>summary 注释:ctrl+m</p>\n<p>多行注释：ctrl+/</p>\n<p>单行注释：ctrl+k</p>\n<h3 id=\"小驼峰和大驼峰\"><a class=\"anchor\" href=\"#小驼峰和大驼峰\">❡</a> 小驼峰和大驼峰</h3>\n<p>&lt;!–code￼3–&gt;</p>\n<h3 id=\"as-和-is\"><a class=\"anchor\" href=\"#as-和-is\">❡</a> As 和 is</h3>\n<p>&lt;!–code￼4–&gt;</p>\n<h3 id=\"类型转换\"><a class=\"anchor\" href=\"#类型转换\">❡</a> 类型转换</h3>\n<p>&lt;!–code￼5–&gt;</p>\n<h4 id=\"自定义转换\"><a class=\"anchor\" href=\"#自定义转换\">❡</a> 自定义转换</h4>\n<p>implicit 和 explicit 不能重复</p>\n<h5 id=\"implicit\"><a class=\"anchor\" href=\"#implicit\">❡</a> implicit</h5>\n<p>&lt;!–code￼6–&gt;</p>\n<h5 id=\"explicit\"><a class=\"anchor\" href=\"#explicit\">❡</a> explicit</h5>\n<p>&lt;!–code￼7–&gt;</p>\n<h3 id=\"创建对象的三种方式\"><a class=\"anchor\" href=\"#创建对象的三种方式\">❡</a> 创建对象的三种方式</h3>\n<p>&lt;!–code￼8–&gt;</p>\n<h3 id=\"方法\"><a class=\"anchor\" href=\"#方法\">❡</a> 方法</h3>\n<p>&lt;!–code￼9–&gt;</p>\n<h3 id=\"out-ref-使用元组组合多个返回值\"><a class=\"anchor\" href=\"#out-ref-使用元组组合多个返回值\">❡</a> Out 、ref、使用元组组合多个返回值</h3>\n<p>&lt;!–code￼10–&gt;</p>\n<h3 id=\"params\"><a class=\"anchor\" href=\"#params\">❡</a> Params</h3>\n<p>&lt;!–code￼11–&gt;</p>\n<h3 id=\"switch\"><a class=\"anchor\" href=\"#switch\">❡</a> Switch</h3>\n<p>&lt;!–code￼12–&gt;</p>\n<h3 id=\"字符串输出转义符-字符和字符串转换\"><a class=\"anchor\" href=\"#字符串输出转义符-字符和字符串转换\">❡</a> 字符串 @输出转义符、字符和字符串转换</h3>\n<p>&lt;!–code￼13–&gt;</p>\n<h3 id=\"字符串null\"><a class=\"anchor\" href=\"#字符串null\">❡</a> 字符串 Null</h3>\n<p>&lt;!–code￼14–&gt;</p>\n<h3 id=\"typeof和sizeof\"><a class=\"anchor\" href=\"#typeof和sizeof\">❡</a> typeof 和 sizeof</h3>\n<p>&lt;!–code￼15–&gt;</p>\n<h3 id=\"和合并运算符\"><a class=\"anchor\" href=\"#和合并运算符\">❡</a> ？和？？（合并运算符）</h3>\n<p>&lt;!–code￼16–&gt;</p>\n<h3 id=\"字符串\"><a class=\"anchor\" href=\"#字符串\">❡</a> 字符串</h3>\n<p>&lt;!–code￼17–&gt;</p>\n<h4 id=\"区域性相关的信息\"><a class=\"anchor\" href=\"#区域性相关的信息\">❡</a> 区域性相关的信息</h4>\n<p>&lt;!–code￼18–&gt;</p>\n<h4 id=\"字符串格式化\"><a class=\"anchor\" href=\"#字符串格式化\">❡</a> 字符串格式化</h4>\n<p>&lt;!–code￼19–&gt;</p>\n<h4 id=\"字符串复合格式化\"><a class=\"anchor\" href=\"#字符串复合格式化\">❡</a> 字符串复合格式化</h4>\n<p>&lt;!–code￼20–&gt;</p>\n<h4 id=\"生成随机数\"><a class=\"anchor\" href=\"#生成随机数\">❡</a> 生成随机数</h4>\n<p>&lt;!–code￼21–&gt;</p>\n<h4 id=\"常见的时间计算\"><a class=\"anchor\" href=\"#常见的时间计算\">❡</a> 常见的时间计算</h4>\n<p>&lt;!–code￼22–&gt;</p>\n<h3 id=\"日期格式化\"><a class=\"anchor\" href=\"#日期格式化\">❡</a> 日期格式化</h3>\n<p>&lt;!–code￼23–&gt;</p>\n<h3 id=\"集合\"><a class=\"anchor\" href=\"#集合\">❡</a> 集合</h3>\n<p>&lt;!–code￼24–&gt;</p>\n<h4 id=\"hashset\"><a class=\"anchor\" href=\"#hashset\">❡</a> HashSet</h4>\n<h5 id=\"issubsetof子集\"><a class=\"anchor\" href=\"#issubsetof子集\">❡</a> IsSubsetOf–子集</h5>\n<h5 id=\"issupersetof父集\"><a class=\"anchor\" href=\"#issupersetof父集\">❡</a> IsSupersetOf–父集</h5>\n<h5 id=\"overlaps交集\"><a class=\"anchor\" href=\"#overlaps交集\">❡</a> Overlaps–交集</h5>\n<h5 id=\"unionwith并集\"><a class=\"anchor\" href=\"#unionwith并集\">❡</a> UnionWith–并集</h5>\n<h5 id=\"removewherenew-predicatetxxx\"><a class=\"anchor\" href=\"#removewherenew-predicatetxxx\">❡</a> RemoveWhere(new Predicate&lt;T&gt;(xxx))</h5>\n<p>&lt;!–code￼25–&gt;</p>\n<h4 id=\"字典\"><a class=\"anchor\" href=\"#字典\">❡</a> 字典</h4>\n<h5 id=\"hashtable与dictionary\"><a class=\"anchor\" href=\"#hashtable与dictionary\">❡</a> HashTable 与 Dictionary</h5>\n<p>&lt;!–code￼26–&gt;</p>\n<h3 id=\"自定义排序\"><a class=\"anchor\" href=\"#自定义排序\">❡</a> 自定义排序</h3>\n<h4 id=\"两种方式\"><a class=\"anchor\" href=\"#两种方式\">❡</a> 两种方式</h4>\n<p>Comparer&lt;T&gt; 类派生，有静态 Default 属性，默认排序方式</p>\n<p>IComparer&lt;T&gt; 接口，必须实现 Compare 方法。</p>\n<p>&lt;!–code￼27–&gt;</p>\n<h3 id=\"控制台应用程序\"><a class=\"anchor\" href=\"#控制台应用程序\">❡</a> 控制台应用程序</h3>\n<h4 id=\"获取文本信息\"><a class=\"anchor\" href=\"#获取文本信息\">❡</a> 获取文本信息</h4>\n<p>&lt;!–code￼28–&gt;</p>\n<h4 id=\"获取键盘输入\"><a class=\"anchor\" href=\"#获取键盘输入\">❡</a> 获取键盘输入</h4>\n<h5 id=\"read\"><a class=\"anchor\" href=\"#read\">❡</a> Read</h5>\n<p>Read (), 每次只读入一个字符，Ctrl+Z 返回 - 1</p>\n<h5 id=\"readkey\"><a class=\"anchor\" href=\"#readkey\">❡</a> ReadKey</h5>\n<p>ReadKey ()，读取用户输入的字符<br />\n ReadKey 返回 ConsoleKeyInfo 实例， 包含三个属性:<strong>Key</strong>（返回 ConsoleKey 枚举）、keyChar（直接返回 Unicode 字符）、<strong>Modifiers</strong> (返回 ConsoleModifiers 枚举值，表示用户是否按下了<strong> Ctrl、Alt、Shift)</strong></p>\n<h5 id=\"readline\"><a class=\"anchor\" href=\"#readline\">❡</a> ReadLine</h5>\n<p>ReadLine () 如果按下<strong> Ctrl+Z+Enter 键会返回 Null</strong></p>\n<h4 id=\"命令行参数\"><a class=\"anchor\" href=\"#命令行参数\">❡</a> 命令行参数</h4>\n<h5 id=\"两种方式-2\"><a class=\"anchor\" href=\"#两种方式-2\">❡</a> 两种方式</h5>\n<p><img data-src=\"C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250112231234605.png\" alt=\"image-20250112231234605\" /></p>\n<p>&lt;!–code￼29–&gt;</p>\n<h4 id=\"控制台窗口的外观\"><a class=\"anchor\" href=\"#控制台窗口的外观\">❡</a> 控制台窗口的外观</h4>\n<h5 id=\"三个属性\"><a class=\"anchor\" href=\"#三个属性\">❡</a> 三个属性</h5>\n<h6 id=\"title\"><a class=\"anchor\" href=\"#title\">❡</a> Title</h6>\n<h6 id=\"backgroundcolor\"><a class=\"anchor\" href=\"#backgroundcolor\">❡</a> BackgroundColor</h6>\n<h6 id=\"foregroundcolor文本颜色也就是前置颜色\"><a class=\"anchor\" href=\"#foregroundcolor文本颜色也就是前置颜色\">❡</a> ForegroundColor–文本颜色也就是前置颜色</h6>\n<p>&lt;!–code￼30–&gt;</p>\n<h4 id=\"控制台窗口的大小和位置\"><a class=\"anchor\" href=\"#控制台窗口的大小和位置\">❡</a> 控制台窗口的大小和位置</h4>\n<h5 id=\"注意点\"><a class=\"anchor\" href=\"#注意点\">❡</a> 注意点：</h5>\n<p>缓冲区大小比窗口大小要大，要先设置窗口大小为 1，1 之后再重新设置。</p>\n<p>WindowTop 以行为单位，WindowLeft 以列为单位。</p>\n<p>ConsoleKey.RightArrow// 右边</p>\n<p>Console.WindowLeft &lt; (Console.BufferWidth - Console.WindowWidth)</p>\n<p>Console.SetWindowPosition(Console.WindowLeft + 1, Console.WindowTop);</p>\n<p>&lt;!–code￼31–&gt;</p>\n<p>响应 CancelKeyPress 事件</p>\n<p>&lt;!–code￼32–&gt;</p>\n<h3 id=\"数组\"><a class=\"anchor\" href=\"#数组\">❡</a> 数组</h3>\n<h4 id=\"定义方式\"><a class=\"anchor\" href=\"#定义方式\">❡</a> 定义方式</h4>\n<p>&lt;!–code￼33–&gt;</p>\n<h4 id=\"复制数组\"><a class=\"anchor\" href=\"#复制数组\">❡</a> 复制数组</h4>\n<p>&lt;!–code￼34–&gt;</p>\n<h4 id=\"查找元素\"><a class=\"anchor\" href=\"#查找元素\">❡</a> 查找元素</h4>\n<h5 id=\"查找元素索引\"><a class=\"anchor\" href=\"#查找元素索引\">❡</a> 查找元素索引</h5>\n<p>&lt;!–code￼35–&gt;</p>\n<h5 id=\"查找元素本身\"><a class=\"anchor\" href=\"#查找元素本身\">❡</a> 查找元素本身</h5>\n<p>&lt;!–code￼36–&gt;</p>\n<h4 id=\"反转数组\"><a class=\"anchor\" href=\"#反转数组\">❡</a> 反转数组</h4>\n<p>&lt;!–code￼37–&gt;</p>\n<h4 id=\"更改数组大小\"><a class=\"anchor\" href=\"#更改数组大小\">❡</a> 更改数组大小</h4>\n<p>&lt;!–code￼38–&gt;</p>\n<h4 id=\"多维数组\"><a class=\"anchor\" href=\"#多维数组\">❡</a> 多维数组</h4>\n<p>&lt;!–code￼39–&gt;</p>\n<h4 id=\"交错数组数组的数组嵌套数组\"><a class=\"anchor\" href=\"#交错数组数组的数组嵌套数组\">❡</a> 交错数组 / 数组的数组 / 嵌套数组</h4>\n<p>&lt;!–code￼40–&gt;</p>\n<h4 id=\"array类\"><a class=\"anchor\" href=\"#array类\">❡</a> Array 类</h4>\n<p>&lt;!–code￼41–&gt;</p>\n<h4 id=\"动态数组\"><a class=\"anchor\" href=\"#动态数组\">❡</a> 动态数组</h4>\n<p>&lt;!–code￼42–&gt;</p>\n<h3 id=\"结构体\"><a class=\"anchor\" href=\"#结构体\">❡</a> 结构体</h3>\n<p>&lt;!–code￼43–&gt;</p>\n<h3 id=\"枚举\"><a class=\"anchor\" href=\"#枚举\">❡</a> 枚举</h3>\n<p>&lt;!–code￼44–&gt;</p>\n<h3 id=\"常用api\"><a class=\"anchor\" href=\"#常用api\">❡</a> 常用 API</h3>\n<h4 id=\"stringbuilder\"><a class=\"anchor\" href=\"#stringbuilder\">❡</a> StringBuilder</h4>\n<p><img data-src=\"C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241230231525811.png\" alt=\"image-20241230231525811\" /></p>\n<p>&lt;!–code￼45–&gt;</p>\n<h4 id=\"正则表达式需要再次学习\"><a class=\"anchor\" href=\"#正则表达式需要再次学习\">❡</a> 正则表达式（需要再次学习）</h4>\n<p>&lt;!–code￼46–&gt;</p>\n<h4 id=\"格式化字符串\"><a class=\"anchor\" href=\"#格式化字符串\">❡</a> 格式化字符串</h4>\n<p>&lt;!–code￼47–&gt;</p>\n<h3 id=\"补充知识\"><a class=\"anchor\" href=\"#补充知识\">❡</a> 补充知识</h3>\n<h4 id=\"泛型\"><a class=\"anchor\" href=\"#泛型\">❡</a> 泛型</h4>\n<p>&lt;!–code￼48–&gt;</p>\n<h4 id=\"顶级语句\"><a class=\"anchor\" href=\"#顶级语句\">❡</a> 顶级语句</h4>\n<h5 id=\"注意点-2\"><a class=\"anchor\" href=\"#注意点-2\">❡</a> 注意点：</h5>\n<ul>\n<li>一个项目中，<strong>只允许一个代码文件</strong>使用顶层语句。</li>\n<li>由于顶层语句在编译时自动生成入口点方法 Main，所以在同一个项目中<strong>不能再选择其他入口点方法</strong>（即编译器选项中不能使用 /main 或 - main 开头）</li>\n</ul>\n<p>&lt;!–code￼49–&gt;</p>\n<h4 id=\"record\"><a class=\"anchor\" href=\"#record\">❡</a> record</h4>\n<p>record 与 class 的区别在于相等比较的计算不同，如果<strong>相同的属性 class 在相等比较运算符上会给出 false</strong>, 而 record 会给出 true.</p>\n<p>&lt;!–code￼50–&gt;</p>\n<h4 id=\"global\"><a class=\"anchor\" href=\"#global\">❡</a> Global</h4>\n<p>​\tglobal using System;</p>\n<h3 id=\"异常处理\"><a class=\"anchor\" href=\"#异常处理\">❡</a> 异常处理</h3>\n<p>&lt;!–code￼51–&gt;</p>\n<h3 id=\"命名空间\"><a class=\"anchor\" href=\"#命名空间\">❡</a> 命名空间</h3>\n<p>作用：避免名称冲突</p>\n<p>不是本项目的需要先引用目标命名空间所在程序集</p>\n<h4 id=\"namespace\"><a class=\"anchor\" href=\"#namespace\">❡</a> NameSpace</h4>\n<p>&lt;!–code￼52–&gt;</p>\n<h4 id=\"using\"><a class=\"anchor\" href=\"#using\">❡</a> using</h4>\n<ol>\n<li>\n<p>起别名</p>\n<p>&lt;!–code￼53–&gt;</p>\n</li>\n<li>\n<p>引入命名空间</p>\n</li>\n<li>\n<p>释放空间</p>\n</li>\n<li>\n<p>静态成员访问</p>\n<p>&lt;!–code￼54–&gt;</p>\n<p><img data-src=\"C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241230231440453.png\" alt=\"image-20241230231440453\" /></p>\n</li>\n</ol>\n<h3 id=\"预处理器指令\"><a class=\"anchor\" href=\"#预处理器指令\">❡</a> 预处理器指令</h3>\n<ul>\n<li>\n<p>#region #endregion</p>\n</li>\n<li>\n<p>#warning 和 #error</p>\n</li>\n<li>\n<p>#lines</p>\n</li>\n<li>\n<p>#pragma</p>\n</li>\n</ul>\n<h3 id=\"文件的输入和输出\"><a class=\"anchor\" href=\"#文件的输入和输出\">❡</a> 文件的输入和输出</h3>\n<p>&lt;!–code￼55–&gt;</p>\n<h3 id=\"不安全代码\"><a class=\"anchor\" href=\"#不安全代码\">❡</a> 不安全代码</h3>\n<h4 id=\"设置\"><a class=\"anchor\" href=\"#设置\">❡</a> 设置</h4>\n<p><img data-src=\"C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241215210857725.png\" alt=\"image-20241215210857725\" /></p>\n<h4 id=\"使用指针检索数据值\"><a class=\"anchor\" href=\"#使用指针检索数据值\">❡</a> 使用指针检索数据值</h4>\n<p>&lt;!–code￼56–&gt;</p>\n<h4 id=\"传递指针作为方法的参数\"><a class=\"anchor\" href=\"#传递指针作为方法的参数\">❡</a> 传递指针作为方法的参数</h4>\n<p>&lt;!–code￼57–&gt;</p>\n<h4 id=\"使用指针访问数组元素\"><a class=\"anchor\" href=\"#使用指针访问数组元素\">❡</a> 使用指针访问数组元素</h4>\n<p>fixed (int *ptr = list), 指针变量在数组中内存固定，其余地方不固定，需要使用 fixed () 来固定</p>\n<p><strong>C# 中声明的变量在内存中的存储受垃圾回收器管理</strong>；因此一个变量（例如一个大数组）有可能在运行过程中被移动到内存中的其他位置。<strong>如果一个变量的内存地址会变化，那么指针也就没有意义了</strong>。</p>\n<p>&lt;!–code￼58–&gt;</p>\n<h2 id=\"面向对象\"><a class=\"anchor\" href=\"#面向对象\">❡</a> 面向对象</h2>\n<h3 id=\"类\"><a class=\"anchor\" href=\"#类\">❡</a> 类</h3>\n<h4 id=\"基础使用\"><a class=\"anchor\" href=\"#基础使用\">❡</a> 基础使用</h4>\n<p>&lt;!–code￼59–&gt;</p>\n<h4 id=\"抽象类\"><a class=\"anchor\" href=\"#抽象类\">❡</a> 抽象类</h4>\n<p>&lt;!–code￼60–&gt;</p>\n<h4 id=\"密封类\"><a class=\"anchor\" href=\"#密封类\">❡</a> 密封类</h4>\n<p>&lt;!–code￼61–&gt;</p>\n<h4 id=\"静态类\"><a class=\"anchor\" href=\"#静态类\">❡</a> 静态类</h4>\n<h5 id=\"单例模式\"><a class=\"anchor\" href=\"#单例模式\">❡</a> 单例模式</h5>\n<p>&lt;!–code￼62–&gt;</p>\n<h5 id=\"静态构造方法\"><a class=\"anchor\" href=\"#静态构造方法\">❡</a> 静态构造方法</h5>\n<p>&lt;!–code￼63–&gt;</p>\n<h3 id=\"只读字段\"><a class=\"anchor\" href=\"#只读字段\">❡</a> 只读字段</h3>\n<p>&lt;!–code￼64–&gt;</p>\n<h3 id=\"字段和属性\"><a class=\"anchor\" href=\"#字段和属性\">❡</a> 字段和属性</h3>\n<p>&lt;!–code￼65–&gt;</p>\n<h3 id=\"init初始化器\"><a class=\"anchor\" href=\"#init初始化器\">❡</a> Init 初始化器</h3>\n<p>&lt;!–code￼66–&gt;</p>\n<h3 id=\"封装\"><a class=\"anchor\" href=\"#封装\">❡</a> 封装</h3>\n<p><img data-src=\"images/image.png\" alt=\"\" /></p>\n<h4 id=\"protected\"><a class=\"anchor\" href=\"#protected\">❡</a> Protected</h4>\n<p>&lt;!–code￼67–&gt;</p>\n<h4 id=\"internal\"><a class=\"anchor\" href=\"#internal\">❡</a> Internal</h4>\n<p><strong>一个项目就是一个程序集</strong>。</p>\n<p>可以通过创建类库，保护级别为 internal，然后在<strong>主函数的解决方案那边添加类库的引用</strong>，从而验证是错误的。</p>\n<p><img data-src=\"C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250111134623676.png\" alt=\"image-20250111134623676\" /></p>\n<p>&lt;!–code￼68–&gt;</p>\n<h4 id=\"protected-internal\"><a class=\"anchor\" href=\"#protected-internal\">❡</a> Protected Internal</h4>\n<p>&lt;!–code￼69–&gt;</p>\n<h3 id=\"多态\"><a class=\"anchor\" href=\"#多态\">❡</a> 多态</h3>\n<h4 id=\"virtual和override-new\"><a class=\"anchor\" href=\"#virtual和override-new\">❡</a> virtual 和 override、new</h4>\n<p>&lt;!–code￼70–&gt;</p>\n<h4 id=\"静态多态\"><a class=\"anchor\" href=\"#静态多态\">❡</a> 静态多态</h4>\n<h5 id=\"方法重载\"><a class=\"anchor\" href=\"#方法重载\">❡</a> 方法重载</h5>\n<p>&lt;!–code￼71–&gt;</p>\n<h5 id=\"运算符重载\"><a class=\"anchor\" href=\"#运算符重载\">❡</a> 运算符重载</h5>\n<p>&lt;!–code￼72–&gt;</p>\n<h4 id=\"动态多态\"><a class=\"anchor\" href=\"#动态多态\">❡</a> 动态多态</h4>\n<p>&lt;!–code￼73–&gt;</p>\n<h3 id=\"继承\"><a class=\"anchor\" href=\"#继承\">❡</a> 继承</h3>\n<p>派生类的可访问性不应该比基类高。这样会避免访问冲突。</p>\n<h4 id=\"定义接口\"><a class=\"anchor\" href=\"#定义接口\">❡</a> 定义接口</h4>\n<p>&lt;!–code￼74–&gt;</p>\n<h4 id=\"接口继承\"><a class=\"anchor\" href=\"#接口继承\">❡</a> 接口继承</h4>\n<p>&lt;!–code￼75–&gt;</p>\n<h4 id=\"显示接口\"><a class=\"anchor\" href=\"#显示接口\">❡</a> 显示接口</h4>\n<p>&lt;!–code￼76–&gt;</p>\n<h2 id=\"高级语法\"><a class=\"anchor\" href=\"#高级语法\">❡</a> 高级语法</h2>\n<h3 id=\"单元测试\"><a class=\"anchor\" href=\"#单元测试\">❡</a> 单元测试</h3>\n<h4 id=\"安装包以及引入的包\"><a class=\"anchor\" href=\"#安装包以及引入的包\">❡</a> 安装包以及引入的包</h4>\n<h5 id=\"安装包\"><a class=\"anchor\" href=\"#安装包\">❡</a> 安装包</h5>\n<ol>\n<li>NUnit</li>\n<li>Microsoft.NET.Test.Sdk</li>\n<li>NUnit3TestAdapter</li>\n</ol>\n<h5 id=\"引入包\"><a class=\"anchor\" href=\"#引入包\">❡</a> 引入包</h5>\n<p>​\t    using NUnit.Framework;</p>\n<h4 id=\"项目属性修改不然会显示main入口不对\"><a class=\"anchor\" href=\"#项目属性修改不然会显示main入口不对\">❡</a> 项目属性修改，不然会显示 Main 入口不对</h4>\n<p><img data-src=\"C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241221141112518.png\" alt=\"image-20241221141112518\" /></p>\n<h4 id=\"基础使用-2\"><a class=\"anchor\" href=\"#基础使用-2\">❡</a> 基础使用</h4>\n<p>onetimesetup 不输出结果，<strong>断言.that (4,Is.equalto (2+3)) 错误会显示结果</strong>，正确没有结果。</p>\n<p>test 的话需要<strong>先运行所有测试</strong>，之后才会有√进行单独的单元测试。</p>\n<p>&lt;!–code￼77–&gt;</p>\n<h3 id=\"断言\"><a class=\"anchor\" href=\"#断言\">❡</a> 断言</h3>\n<p>作用：检验代码的执行是否符合预期的结果。</p>\n<p>&lt;!–code￼78–&gt;</p>\n<h3 id=\"使用日志文件\"><a class=\"anchor\" href=\"#使用日志文件\">❡</a> 使用日志文件</h3>\n<p><img data-src=\"C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250114123433406.png\" alt=\"image-20250114123433406\" /></p>\n<p>&lt;!–code￼79–&gt;</p>\n<h3 id=\"反射\"><a class=\"anchor\" href=\"#反射\">❡</a> 反射</h3>\n<p>GetMethod、GetConstructor 都与 invoke 有关</p>\n<p>var Obj = assembly.CreateInstance(「MyStudyProcess_C#Senior.MyTest」,false);<a href=\"//xn--eqrzj591h57w.xn--eqrt45g\">// 命名空间。类名</a></p>\n<p>&lt;!–code￼80–&gt;</p>\n<p>&lt;!–code￼81–&gt;</p>\n<p>&lt;!–code￼82–&gt;</p>\n<h3 id=\"扩展知识\"><a class=\"anchor\" href=\"#扩展知识\">❡</a> 扩展知识</h3>\n<h4 id=\"扩展方法\"><a class=\"anchor\" href=\"#扩展方法\">❡</a> 扩展方法</h4>\n<p>自定义扩展方法</p>\n<p>1、静态类</p>\n<p>2、静态方法</p>\n<p>3、参数列表前加上 this</p>\n<p>扩展方法向现有类型 “添加” 方法，而无需创建新的派生类型、重新编译或以其他方式修改原始类型。</p>\n<p>扩展方法是一种静态方法，但可以像扩展类型上的实例方法一样进行调用。</p>\n<p>&lt;!–code￼83–&gt;</p>\n<h4 id=\"特性\"><a class=\"anchor\" href=\"#特性\">❡</a> 特性</h4>\n<h5 id=\"自定义特性\"><a class=\"anchor\" href=\"#自定义特性\">❡</a> 自定义特性</h5>\n<p>&lt;!–code￼84–&gt;</p>\n<h5 id=\"预定义特性\"><a class=\"anchor\" href=\"#预定义特性\">❡</a> 预定义特性</h5>\n<p>.Net 框架提供了三种预定义特性：</p>\n<ul>\n<li>AttributeUsage</li>\n<li>Conditional–条件，#define xxx</li>\n<li>Obsolete–可以用旧的方法</li>\n</ul>\n<p>&lt;!–code￼85–&gt;</p>\n<p>创建并使用自定义特性包含四个步骤：</p>\n<ul>\n<li>声明自定义特性</li>\n<li>构建自定义特性</li>\n<li>在目标程序元素上应用自定义特性</li>\n<li>通过反射访问特性</li>\n</ul>\n<p>&lt;!–code￼86–&gt;</p>\n<h4 id=\"索引器\"><a class=\"anchor\" href=\"#索引器\">❡</a> 索引器</h4>\n<p>&lt;!–code￼87–&gt;</p>\n<h4 id=\"序列化\"><a class=\"anchor\" href=\"#序列化\">❡</a> 序列化</h4>\n<h5 id=\"二进制序列化\"><a class=\"anchor\" href=\"#二进制序列化\">❡</a> 二进制序列化</h5>\n<p>&lt;!–code￼88–&gt;</p>\n<p>&lt;!–code￼89–&gt;</p>\n<h5 id=\"xml序列化\"><a class=\"anchor\" href=\"#xml序列化\">❡</a> XML 序列化</h5>\n<p>&lt;!–code￼90–&gt;</p>\n<h5 id=\"自定义xml文档的节点\"><a class=\"anchor\" href=\"#自定义xml文档的节点\">❡</a> 自定义 xml 文档的节点</h5>\n<p>&lt;!–code￼91–&gt;</p>\n<p>&lt;!–code￼92–&gt;</p>\n<h5 id=\"数据协定\"><a class=\"anchor\" href=\"#数据协定\">❡</a> 数据协定</h5>\n<p>数据交互过程对象不一定相同类型，必须遵循数据协定来定义。</p>\n<p>&lt;!–code￼93–&gt;</p>\n<h5 id=\"json序列化\"><a class=\"anchor\" href=\"#json序列化\">❡</a> JSon 序列化</h5>\n<p>&lt;!–code￼94–&gt;</p>\n<h6 id=\"jsonserializer\"><a class=\"anchor\" href=\"#jsonserializer\">❡</a> JsonSerializer</h6>\n<p>&lt;!–code￼95–&gt;</p>\n<h6 id=\"自定义转换器\"><a class=\"anchor\" href=\"#自定义转换器\">❡</a> 自定义转换器</h6>\n<p>&lt;!–code￼96–&gt;</p>\n<h6 id=\"自定义属性名称\"><a class=\"anchor\" href=\"#自定义属性名称\">❡</a> 自定义属性名称</h6>\n<p>&lt;!–code￼97–&gt;</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmVqc29uLmNvbS8=\">在线 JSON 校验格式化工具（Be JSON）</span></p>\n<p>&lt;!–code￼98–&gt;</p>\n<h3 id=\"泛型-2\"><a class=\"anchor\" href=\"#泛型-2\">❡</a> 泛型</h3>\n<p>由于泛型委托 xxx&lt;T&gt; 的类型参数 T 是固定的，也就是不可变体，所以无法隐式转换.</p>\n<p>public delegate TResult Func&lt;in T1,in T2,out TResult&gt;(T1 arg1,T2 arg2);</p>\n<h4 id=\"协变\"><a class=\"anchor\" href=\"#协变\">❡</a> 协变</h4>\n<p>out 只能用于接口</p>\n<p>父类 = 子类</p>\n<p>&lt;!–code￼99–&gt;</p>\n<h4 id=\"逆变\"><a class=\"anchor\" href=\"#逆变\">❡</a> 逆变</h4>\n<p>&lt;!–code￼100–&gt;</p>\n<h4 id=\"泛型的应用\"><a class=\"anchor\" href=\"#泛型的应用\">❡</a> 泛型的应用</h4>\n<h5 id=\"手写orm框架很难\"><a class=\"anchor\" href=\"#手写orm框架很难\">❡</a> 手写 ORM 框架（很难）</h5>\n<p>ORM 框架，对象关系映射。</p>\n<ul>\n<li>从老师提供 utils 文件夹中将 DbHelper 拷贝至当前你的项目中</li>\n<li>nuget 引用：\n<ul>\n<li>1：Microsoft.Extensions.Configuration，</li>\n<li>2：System.Data.SqlClient</li>\n</ul>\n</li>\n<li>封装 ORM 框架</li>\n</ul>\n<p>&lt;!–code￼101–&gt;</p>\n<h5 id=\"datatable-转-list\"><a class=\"anchor\" href=\"#datatable-转-list\">❡</a> <strong>DataTable</strong> <strong>转</strong> <strong>List</strong></h5>\n<p>DataTable 转换成 List</p>\n<p>&lt;!–code￼102–&gt;</p>\n<h3 id=\"泛型集合\"><a class=\"anchor\" href=\"#泛型集合\">❡</a> 泛型集合</h3>\n<h4 id=\"存在的问题\"><a class=\"anchor\" href=\"#存在的问题\">❡</a> 存在的问题</h4>\n<p>&lt;!–code￼103–&gt;</p>\n<h4 id=\"性能对比\"><a class=\"anchor\" href=\"#性能对比\">❡</a> 性能对比</h4>\n<h5 id=\"非泛型集合性能\"><a class=\"anchor\" href=\"#非泛型集合性能\">❡</a> 非泛型集合性能</h5>\n<p>&lt;!–code￼104–&gt;</p>\n<h5 id=\"泛型集合性能\"><a class=\"anchor\" href=\"#泛型集合性能\">❡</a> 泛型集合性能</h5>\n<p>&lt;!–code￼105–&gt;</p>\n<h3 id=\"io文件流\"><a class=\"anchor\" href=\"#io文件流\">❡</a> I/O 文件流</h3>\n<h4 id=\"stream流\"><a class=\"anchor\" href=\"#stream流\">❡</a> Stream 流</h4>\n<p>&lt;!–code￼106–&gt;</p>\n<h4 id=\"内存映射文件\"><a class=\"anchor\" href=\"#内存映射文件\">❡</a> 内存映射文件</h4>\n<p>内存映射文件可以单独存放于内存中，也可以把磁盘上的文件映射为内存文件来进行处理.</p>\n<p>&lt;!–code￼107–&gt;</p>\n<p>&lt;!–code￼108–&gt;</p>\n<h4 id=\"独立存储\"><a class=\"anchor\" href=\"#独立存储\">❡</a> 独立存储</h4>\n<p>独立存储也叫隔离存储，是一个由操作系统提供的、可以存储文件和目录的一个特殊区域。</p>\n<p>&lt;!–code￼109–&gt;</p>\n<h3 id=\"委托\"><a class=\"anchor\" href=\"#委托\">❡</a> 委托</h3>\n<ul>\n<li>1、委托的本质就是一个 Sealed 类</li>\n<li>2、继承自 System.MulticastDelegate:Delegate</li>\n<li>3、委托里面内置了 3 个方法：Invoke (),BeginInvoke (),EndInvoke ()。</li>\n</ul>\n<p>重要结论</p>\n<blockquote>\n<ol>\n<li>参数列表和返回值称为<strong>方法签名</strong></li>\n<li>委托的签名要与方法的签名保持一致</li>\n</ol>\n</blockquote>\n<p>&lt;!–code￼110–&gt;</p>\n<h4 id=\"弃元-匿名方法与-lambda-表达式\"><a class=\"anchor\" href=\"#弃元-匿名方法与-lambda-表达式\">❡</a> 弃元、匿名方法与 Lambda 表达式</h4>\n<h5 id=\"弃元\"><a class=\"anchor\" href=\"#弃元\">❡</a> 弃元</h5>\n<p>&lt;!–code￼111–&gt;</p>\n<h5 id=\"匿名方法\"><a class=\"anchor\" href=\"#匿名方法\">❡</a> 匿名方法</h5>\n<p>&lt;!–code￼112–&gt;</p>\n<h5 id=\"lambda-表达式\"><a class=\"anchor\" href=\"#lambda-表达式\">❡</a> Lambda 表达式</h5>\n<ul>\n<li>Lambda 表达式是一个匿名函数，用它可以高效简化代码，常用作委托，回调</li>\n<li>Lambda 表达式都使用运算符 =&gt; ，所以当你见到这个符号，基本上就是一个 Lambda 表达式</li>\n<li>Lambda 运算符的左边是输入参数 ()， =&gt; ，右边是表达式或语句块</li>\n<li>Lambda 表达式，是可以访问到外部变量的</li>\n</ul>\n<p>&lt;!–code￼113–&gt;</p>\n<h4 id=\"系统内置委托\"><a class=\"anchor\" href=\"#系统内置委托\">❡</a> 系统内置委托</h4>\n<h5 id=\"action\"><a class=\"anchor\" href=\"#action\">❡</a> Action</h5>\n<p>Action 无返回值的内置委托，有 16 个重载方法:</p>\n<ul>\n<li>Action 声明无参数委托</li>\n<li>Action 声明有一个参数委托</li>\n<li>Action  声明有 2 个参数委托</li>\n<li>Action  声明有 3 个参数委托</li>\n<li>Action  委托输入参数个数最多 16 个。</li>\n</ul>\n<p>备注</p>\n<blockquote>\n<p>1、它有 16 重载方法</p>\n<p>2、有 16 个输入参数</p>\n<p>3、 Action 的返回类型是 Void</p>\n</blockquote>\n<p>&lt;!–code￼114–&gt;</p>\n<h5 id=\"functtresult\"><a class=\"anchor\" href=\"#functtresult\">❡</a> Func&lt;T,TResult&gt;</h5>\n<p>Func 有返回值的内置委托，有 17 个重载方法:</p>\n<ul>\n<li>1、Func</li>\n<li>2、Func&lt;T,TResult&gt;</li>\n<li>3、 Func&lt;T1,T2,TResult&gt;</li>\n<li>4、 Func&lt;T1,T2,T3,TResult&gt;</li>\n<li>5 、Func&lt;T1,…,TResult&gt;</li>\n</ul>\n<p>备注</p>\n<blockquote>\n<p>1、它有 17 个重载方法</p>\n<p>2、有 T1 到 T16 个输入参数</p>\n<p>3、<strong>最后一个参数 Tresult 代表返回类型</strong></p>\n</blockquote>\n<p>&lt;!–code￼115–&gt;</p>\n<h4 id=\"委托异步调用\"><a class=\"anchor\" href=\"#委托异步调用\">❡</a> 委托异步调用</h4>\n<p>特点：</p>\n<ul>\n<li>异步调用，即在线程池分配的子线程中执行委托，因此执行时不会阻塞调用委托的线程，该线程在 调用后不等委托结束继续向下执行。</li>\n<li>委托结束时，如果有返回值，子线程将返回值传递给调用线程；</li>\n<li>委托方法执行结束后，如果有回调函数，则在子线程中继续执行回调函数，直到回调函数结束委托 才结束。</li>\n</ul>\n<p>&lt;!–code￼116–&gt;</p>\n<p>但是上述代码会抛出异常<strong> System.PlatformNotSupportedException : Operation is not supported on this platform.</strong></p>\n<p>原因如下：</p>\n<blockquote>\n<p>异步编程模型 (APM)(使用 IAsyncResult 和 BeginInvoke) 不再是异步调用的优选方法。<span class=\"exturl\" data-url=\"aHR0cDovL3huLS0wbXEuTkVU\">从.NET</span> Framework 4.5 开始，推荐的异步模型是基于任务的异步模式 (TAP)。因此，而且由于异步委托的 实现取决于远程处理，<span class=\"exturl\" data-url=\"aHR0cDovL3huLS1ncXEuTkVU\">但.NET</span> Core 中 是不存在的功能，BeginInvoke 和 EndInvoke 委托调用不支 持 .NET Core</p>\n</blockquote>\n<h5 id=\"使用任务实现异步调用\"><a class=\"anchor\" href=\"#使用任务实现异步调用\">❡</a> 使用任务实现异步调用</h5>\n<p>&lt;!–code￼117–&gt;</p>\n<h3 id=\"event-事件\"><a class=\"anchor\" href=\"#event-事件\">❡</a> event 事件</h3>\n<p>&lt;!–code￼118–&gt;</p>\n<h4 id=\"事件的本质\"><a class=\"anchor\" href=\"#事件的本质\">❡</a> <strong>事件的本质</strong></h4>\n<p>通过<strong>反射</strong>我们可以得出结果：</p>\n<ul>\n<li>IsClass: true</li>\n<li>父类是 MulticastDelegate，成员方法 Invoke，BeginInvoke，EndInvoke</li>\n<li>IsSealed: true</li>\n<li>结论：事件是一个委托，并且还是一个特殊的密封类。</li>\n</ul>\n<h4 id=\"事件与委托的区别\"><a class=\"anchor\" href=\"#事件与委托的区别\">❡</a> <strong>事件与委托的区别</strong></h4>\n<ul>\n<li>事件只能在类的内部进行触发，不能在类的外部进行触发。而委托在类的内部和外部都可触发；</li>\n<li>委托一般用于回调，而事件一般用于外部接口。在观察者模式中，被观察者可在内部声明一个事件</li>\n<li>作为外部观察者注册的接口。</li>\n<li>事件只能通过 +=，-= 方式 绑定 / 解绑方式</li>\n<li>事件是一个特殊的委托，查看反编译工具之后的代码，发现<strong>事件是一个 private 委托</strong></li>\n</ul>\n<h3 id=\"观察者模式\"><a class=\"anchor\" href=\"#观察者模式\">❡</a> <strong>观察者模式</strong></h3>\n<h4 id=\"错误写法\"><a class=\"anchor\" href=\"#错误写法\">❡</a> 错误写法</h4>\n<p>&lt;!–code￼119–&gt;</p>\n<h4 id=\"正确写法\"><a class=\"anchor\" href=\"#正确写法\">❡</a> 正确写法</h4>\n<p>Observer 设计模式中主要包括如下两类对象：</p>\n<ol>\n<li>\n<p><strong>Subject：监视对象（被观察者）</strong>，它往往包含着其他对象所感兴趣的内容。在本范例中，<strong>热水器</strong></p>\n<p>就是一个监视对象，它包含的其他对象所感兴趣的内容，就是 temprature 字段，当这个字段的值</p>\n<p>快到 100 时，会不断把数据发给监视它的对象。</p>\n</li>\n<li>\n<p><strong>Observer：观察者</strong>，它监视 Subject，当 Subject 中的某件事发生的时候，会告知 Observer，而</p>\n<p>Observer 则会采取相应的行动。在本范例中，<strong>Observer 有警报器和显示器</strong>，它们采取的行动分别</p>\n<p>是发出警报和显示水温。</p>\n</li>\n</ol>\n<p>在本例中，事情发生的顺序应该是这样的：</p>\n<ol>\n<li>警报器和显示器告诉热水器，它对它的温度比较感兴趣 (注册)。</li>\n<li>热水器知道后保留对警报器和显示器的引用。</li>\n<li>热水器进行烧水这一动作，当水温超过 95 度时，通过对警报器和显示器的引用，自动调用警报器</li>\n</ol>\n<p>的 MakeAlert () 方法、显示器的 ShowMsg () 方法。</p>\n<p>类似这样的例子是很多的，GOF (设计模式) 对它进行了抽象，称为 Observer 设计模式：<strong>Observer**** 设计</strong></p>\n<p><strong>模式是为了定义对象间的一种一对多的依赖关系，以便于当一个对象的状态改变时，其他依赖于它的对</strong></p>\n<p><strong>象会被自动告知并更新。<strong><strong>Observer</strong></strong> 模式是一种松耦合的设计模式。</strong></p>\n<p>观察者模式，也叫<strong>发布订阅模式</strong></p>\n<p>&lt;!–code￼120–&gt;</p>\n<h3 id=\"表达式树\"><a class=\"anchor\" href=\"#表达式树\">❡</a> <strong>表达式树</strong></h3>\n<h4 id=\"expression-类\"><a class=\"anchor\" href=\"#expression-类\">❡</a> <strong>Expression</strong> <strong>类</strong></h4>\n<p>​\t提供一种基类，表示表达式树节点的类派生自该基类。 它还包含用来创建各种节点类型 (表达式类型) 的</p>\n<p>static 工厂方法。 这是一个 abstract 类。</p>\n<h5 id=\"应用场景\"><a class=\"anchor\" href=\"#应用场景\">❡</a> <strong>应用场景：</strong></h5>\n<ol>\n<li>自定义 ORM 框架查询条件 (用来检查用户信息合法性)</li>\n<li>规则引擎</li>\n</ol>\n<h5 id=\"常用表达式\"><a class=\"anchor\" href=\"#常用表达式\">❡</a> <strong>常用表达式</strong></h5>\n<h6 id=\"1-常量表达式-constantexpression\"><a class=\"anchor\" href=\"#1-常量表达式-constantexpression\">❡</a> <strong>1.</strong> <strong>常量表达式</strong> **-ConstantExpression**</h6>\n<p>&lt;!–code￼121–&gt;</p>\n<h6 id=\"2-参数表达式-parameterexpression\"><a class=\"anchor\" href=\"#2-参数表达式-parameterexpression\">❡</a> <strong>2.</strong> <strong>参数表达式</strong> **-ParameterExpression**</h6>\n<p>&lt;!–code￼122–&gt;</p>\n<h6 id=\"3-二叉二元表达式-binaryexpression\"><a class=\"anchor\" href=\"#3-二叉二元表达式-binaryexpression\">❡</a> <strong>3.</strong> <strong>二叉（二元）表达式</strong> **-BinaryExpression**</h6>\n<p>&lt;!–code￼123–&gt;</p>\n<h6 id=\"4-lambda表达式\"><a class=\"anchor\" href=\"#4-lambda表达式\">❡</a> <strong>4. Lambda**** 表达式</strong></h6>\n<p>&lt;!–code￼124–&gt;</p>\n<h6 id=\"5-成员表达式-memberexpression\"><a class=\"anchor\" href=\"#5-成员表达式-memberexpression\">❡</a> <strong>5.</strong> <strong>成员表达式</strong> **-MemberExpression**</h6>\n<p>&lt;!–code￼125–&gt;</p>\n<h6 id=\"6-方法表达式-methodcallexpression\"><a class=\"anchor\" href=\"#6-方法表达式-methodcallexpression\">❡</a> <strong>6.</strong> <strong>方法表达式</strong> **-MethodCallExpression**</h6>\n<p>&lt;!–code￼126–&gt;</p>\n<h6 id=\"7-成员初始化表达式-memberbinding\"><a class=\"anchor\" href=\"#7-成员初始化表达式-memberbinding\">❡</a> <strong>7.</strong> <strong>成员初始化表达式</strong> **-MemberBinding**</h6>\n<p>&lt;!–code￼127–&gt;</p>\n<h5 id=\"表达式实战很难\"><a class=\"anchor\" href=\"#表达式实战很难\">❡</a> <strong>表达式实战</strong>（很难）</h5>\n<h6 id=\"mytest\"><a class=\"anchor\" href=\"#mytest\">❡</a> MyTest</h6>\n<p>&lt;!–code￼128–&gt;</p>\n<h6 id=\"1-automap-自动映射框架\"><a class=\"anchor\" href=\"#1-automap-自动映射框架\">❡</a> <strong>1. AutoMap</strong> <strong>自动映射框架</strong></h6>\n<p>&lt;!–code￼129–&gt;</p>\n<p><strong>方法测试</strong></p>\n<p>&lt;!–code￼130–&gt;</p>\n<h6 id=\"2-orm-条件表达式\"><a class=\"anchor\" href=\"#2-orm-条件表达式\">❡</a> <strong>2. ORM</strong> <strong>条件表达式</strong></h6>\n<p>EF 框架中 一般可以将 Expression 表达式作为查询条件，但如果是自定义的 ORM 框架，我们该如何将</p>\n<p>Expression 表达式生成可执行的 SQL 呢？</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3huLS1Bc3AtZTgyZjg5MGEubmV0\">新建 Asp.net</span> Mvc 项目，搭建 EF 框架</li>\n</ul>\n<p>（1）Nuget 安装： microsoft.entityframeworkcore，</p>\n<p>microsoft.entityframeworkcore.sqlserver</p>\n<p>&lt;!–code￼131–&gt;</p>\n<ul>\n<li>\n<p>在 Program 中加下如下代码：</p>\n<p>&lt;!–code￼132–&gt;</p>\n<p>appsettings.json 配置如下：</p>\n<p>&lt;!–code￼133–&gt;</p>\n</li>\n<li>\n<p>自定义类 CustomerVisitor 继承至 ExpressionVisitor</p>\n<p>假设你要执行的表达式如下：</p>\n<p>&lt;!–code￼134–&gt;</p>\n<p>ExpressionVisitor 可以解析 Expression 表达式中每一个节点的执行过程</p>\n<p>&lt;!–code￼135–&gt;</p>\n</li>\n<li>\n<p>测试调用</p>\n<p>&lt;!–code￼136–&gt;</p>\n</li>\n</ul>\n<h3 id=\"系统信息管理\"><a class=\"anchor\" href=\"#系统信息管理\">❡</a> 系统信息管理</h3>\n<h4 id=\"管理服务\"><a class=\"anchor\" href=\"#管理服务\">❡</a> 管理服务</h4>\n<p>&lt;!–code￼137–&gt;</p>\n<h4 id=\"wmi查询\"><a class=\"anchor\" href=\"#wmi查询\">❡</a> WMI 查询</h4>\n<p>&lt;!–code￼138–&gt;</p>\n<h4 id=\"读取系统参数\"><a class=\"anchor\" href=\"#读取系统参数\">❡</a> 读取系统参数</h4>\n<h5 id=\"environment类\"><a class=\"anchor\" href=\"#environment类\">❡</a> Environment 类</h5>\n<p>&lt;!–code￼139–&gt;</p>\n<h5 id=\"systeminformation类\"><a class=\"anchor\" href=\"#systeminformation类\">❡</a> SystemInformation 类</h5>\n<p>&lt;!–code￼140–&gt;</p>\n<h4 id=\"写入事件日志\"><a class=\"anchor\" href=\"#写入事件日志\">❡</a> 写入事件日志</h4>\n<p>&lt;!–code￼141–&gt;</p>\n<h3 id=\"进程与线程\"><a class=\"anchor\" href=\"#进程与线程\">❡</a> <strong>进程与线程</strong></h3>\n<h4 id=\"进程操作\"><a class=\"anchor\" href=\"#进程操作\">❡</a> 进程操作</h4>\n<h5 id=\"process类\"><a class=\"anchor\" href=\"#process类\">❡</a> Process 类</h5>\n<p>&lt;!–code￼142–&gt;</p>\n<h5 id=\"获取进程列表\"><a class=\"anchor\" href=\"#获取进程列表\">❡</a> <strong>获取进程列表</strong></h5>\n<p>&lt;!–code￼143–&gt;</p>\n<h5 id=\"重定向输入输出流\"><a class=\"anchor\" href=\"#重定向输入输出流\">❡</a> 重定向输入 / 输出流</h5>\n<p>&lt;!–code￼144–&gt;</p>\n<h4 id=\"多线程\"><a class=\"anchor\" href=\"#多线程\">❡</a> <strong>多线程</strong></h4>\n<h5 id=\"net-中如何实现多线程\"><a class=\"anchor\" href=\"#net-中如何实现多线程\">❡</a> <strong>.net</strong> <strong>中如何实现多线程</strong></h5>\n<ol>\n<li>线程肯定也是要执行一段代码的。所以要产生一个线程，必须要先为这个线程写一段它即将要执行的一段代码（方法），<strong>相当于是找个人来帮忙做事</strong>。</li>\n<li>线程启动时，通过<strong>委托</strong>来调用该方法（委托的好处），</li>\n<li>线程启动时，调用传过来的委托，委托就会执行相应的方法，实现线程执行方法。</li>\n</ol>\n<h4 id=\"多线程开发\"><a class=\"anchor\" href=\"#多线程开发\">❡</a> <strong>多线程开发</strong></h4>\n<h5 id=\"1-单线程带来的问题\"><a class=\"anchor\" href=\"#1-单线程带来的问题\">❡</a> <strong>1.</strong> <strong>单线程带来的问题</strong></h5>\n<p>​\t如果主线程需要执行某个占时很多的任务，如果此时再想对这个 UI 操作其他任务，就需要排队等待或者</p>\n<p>出现无响应的情况。</p>\n<p><img data-src=\"C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241216102109940.png\" alt=\"image-20241216102109940\" /></p>\n<p>&lt;!–code￼145–&gt;</p>\n<p>​\t在点击按钮的之后，UI 线程已经处于阻塞状态，界面无法拖动，只有当循环结束之后，我们才可以对界</p>\n<p>面进行下一步操作。</p>\n<h5 id=\"2-使用多线程解决问题\"><a class=\"anchor\" href=\"#2-使用多线程解决问题\">❡</a> <strong>2.</strong> <strong>使用多线程解决问题</strong></h5>\n<p><img data-src=\"C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241216103119807.png\" alt=\"image-20241216103119807\" /></p>\n<p>&lt;!–code￼146–&gt;</p>\n<h5 id=\"3-前后台线程\"><a class=\"anchor\" href=\"#3-前后台线程\">❡</a> <strong>3.</strong> <strong>前后台线程</strong></h5>\n<p>​\tThread 对象在创建时，默认为<strong>前台线程</strong>，也就是<strong> IsBackground = false</strong> 。前端线程的特点是：</p>\n<ul>\n<li>只有当所有的前台线程都关闭，程序才会真正的退出。</li>\n<li>即使主线程关了，前台线程也要将它所执行的任务执行完成才会退出。</li>\n</ul>\n<p>&lt;!–code￼147–&gt;</p>\n<h5 id=\"4-线程之间参数传递\"><a class=\"anchor\" href=\"#4-线程之间参数传递\">❡</a> <strong>4.</strong> <strong>线程之间参数传递</strong></h5>\n<p>&lt;!–code￼148–&gt;</p>\n<h4 id=\"线程安全\"><a class=\"anchor\" href=\"#线程安全\">❡</a> <strong>线程安全</strong></h4>\n<h5 id=\"跨线程控件调用\"><a class=\"anchor\" href=\"#跨线程控件调用\">❡</a> <strong>跨线程控件调用</strong></h5>\n<h6 id=\"问题\"><a class=\"anchor\" href=\"#问题\">❡</a> 问题</h6>\n<p><img data-src=\"C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241216104017912.png\" alt=\"image-20241216104017912\" /></p>\n<p>&lt;!–code￼149–&gt;</p>\n<p><img data-src=\"C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241216011559213.png\" alt=\"image-20241216011559213\" /></p>\n<h6 id=\"解决方案1\"><a class=\"anchor\" href=\"#解决方案1\">❡</a> <strong>解决方案<strong><strong> 1</strong></strong>：</strong></h6>\n<p>&lt;!–code￼150–&gt;</p>\n<p>​\tCheckForIllegalCrossThreadCalls =true; 的时候 .net 会对程序使用 UI 控件进行安全检查 ，避免跨线程</p>\n<p>导致的死锁、状态不对的 bug 。而 CheckForIllegalCrossThreadCalls =false;.net 不会对程序使用 UI 控件</p>\n<p>进行安全检查，全靠程序员自己避免以上 bug，<strong>实际上还是多个线程对界面控件操作</strong> 。</p>\n<h6 id=\"解决方案2\"><a class=\"anchor\" href=\"#解决方案2\">❡</a> <strong>解决方案<strong><strong> 2</strong></strong>：</strong></h6>\n<p>&lt;!–code￼151–&gt;</p>\n<h5 id=\"线程并发\"><a class=\"anchor\" href=\"#线程并发\">❡</a> <strong>线程并发</strong></h5>\n<h6 id=\"抛出问题\"><a class=\"anchor\" href=\"#抛出问题\">❡</a> <strong>抛出问题</strong></h6>\n<p>&lt;!–code￼152–&gt;</p>\n<h6 id=\"lock-关键字解决并发\"><a class=\"anchor\" href=\"#lock-关键字解决并发\">❡</a> <strong>lock</strong> <strong>关键字解决并发</strong></h6>\n<p><strong>作用：</strong> lock 关键字可以用来确保代码块完成运行，而不会被其他线程中断。它可以把一段代码定义为</p>\n<p>互斥段（critical section），互斥段在一个时刻内只允许一个线程进入执行，而其他线程必须等待。这</p>\n<p>是通过在代码块运行期间为给定对象获取互斥锁来实现的。在多线程中，每个线程都有自己的资源，但</p>\n<p>是代码区是共享的，即每个线程都可以执行相同的函数。这可能带来的问题就是几个线程同时执行一个</p>\n<p>函数，导致数据的混乱，产生不可预料的结果，因此我们必须避免这种情况的发生。</p>\n<p><strong>缺点：</strong> 多线程中频繁使用 lock 会造成性能损耗。</p>\n<p>&lt;!–code￼153–&gt;</p>\n<h6 id=\"注意事项及原理\"><a class=\"anchor\" href=\"#注意事项及原理\">❡</a> <strong>注意事项及原理</strong></h6>\n<ul>\n<li>\n<p><strong>2.1**** 注意事项</strong></p>\n<p>当同步对共享资源的线程访问时，请锁定专用对象实例（例如，private static readonly object Lock =</p>\n<p>new ();）或另一个不太可能被代码无关部分用作 lock 对象的实例。 避免对不同的共享资源使用相同的</p>\n<p>lock 对象实例，因为这可能导致死锁或锁争用。</p>\n</li>\n<li>\n<p>具体而言，<strong>避免将以下对象用作</strong> <strong>lock</strong> <strong>对象</strong></p>\n<ul>\n<li>this（调用方可能将其用作 lock）。</li>\n<li>Type 实例（可以通过 typeof 运算符或反射获取）。</li>\n<li>字符串实例，包括字符串文本，（这些可能是暂存的）。</li>\n<li>尽可能缩短持有锁的时间，以减少锁争用。</li>\n<li>在 lock 语句的正文中不能使用 await 运算符。</li>\n<li>特别要注意，不要用值类型</li>\n</ul>\n</li>\n<li>\n<p><strong>2.2**** 原理</strong> (以下内容比较浅显，太深究内容一篇文章写不完)</p>\n<ul>\n<li>\n<p><strong>Q1</strong>**：** 大家会注意到，为什么要在 lock 的圆括号里放一个引用类型 object？为什么不可以放一个值类型如 int？</p>\n<ul>\n<li>\n<p><strong>A1</strong>**：** 因为如果使用了值类型例如 int 作为 lock 锁定的对象，lock 圆括号中的入参是 object 类型当传入了值类型会对传入的对象类型进行转换，那么在 IL 层面会对值类型进行一次装箱（box）操作。那么这种情况下就不具备 lock 锁定需要用到专用对象的稳定性了。</p>\n<ul>\n<li>\n<p>​\t\t\t\t\tIL_0002:ldloc.0</p>\n</li>\n<li>\n<p>​\t\t\t\t\tIL_0003:box [mscorlib]System.Int32</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>A2</strong>**：** 值类型 一般都在线程函数自己的栈里，每个线程局部栈是不一样的，互相之间不会有影响，所以不用锁定一个特例，引用类型值类型字段在堆里，但可以通过 lock 那个引用类型对象就可以实现了</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"monitor-监视器\"><a class=\"anchor\" href=\"#monitor-监视器\">❡</a> <strong>Monitor</strong> <strong>监视器</strong></h5>\n<p>​\t\t<strong>首先<strong><strong> lock</strong></strong> 和<strong><strong> Minitor</strong></strong> 有什么区别呢？</strong></p>\n<p>​\t\t\t其实 lock 在 IL 代码中会被翻译成 Monitor。也就是 Monitor.Enter (obj) 和 Monitor.Exit (obj).</p>\n<p>​\t\t\t微软很照护我们，给了我们语法糖 Lock, 对的，语言糖确实减少了我们不必要的劳动并且让代码更可观，但是如果我们要精细的控制，则必须使用原生类，这里要注意一个问题就是 “锁住什么” 的问题，一般情况下我们锁住的都是静态对象，我们知道静态对象属于类级别，当有很多线程共同访问的时候，那个静态对象对多个线程来说是一个，不像实例字段会被认为是多个。</p>\n<p>&lt;!–code￼154–&gt;</p>\n<p>等价于：</p>\n<p>&lt;!–code￼155–&gt;</p>\n<p>所以 lock 能做的，Monitor 肯定能做，Monitor 能做的，lock 不一定能做。那么 Monitor 额外的功能呢？</p>\n<ol>\n<li>\n<p>Monitor.TryEnter (obj,timespan)----timeout 之后，就不执行这段代码了。lock 可是一直会死等的。</p>\n</li>\n<li>\n<p>还有 Monitor.Wait () 和 Monitor.Pulse ()。在 lock 代码里面如果调用了 Monitor.Wait ()，会放弃对资源的所有权，让别的线程 lock 进来。然后别的线程代码里 Pulse 一下（让原线程进入到等待队列），然后在 Wait 一下释放资源，这样原线程的就可以继续执行了（代码还堵塞在 wait 那句话呢）。也就是说，必须两个或多个线程共同调用 Wait 和 Pulse，把资源的所有权抛来抛去，才不会死锁</p>\n</li>\n</ol>\n<h6 id=\"生产者消费者模式需要反复学习\"><a class=\"anchor\" href=\"#生产者消费者模式需要反复学习\">❡</a> <strong>生产者消费者模式</strong>（需要反复学习）</h6>\n<p>​\t请用线程结合队列模拟生产者 - 消费者模式，需求描述如下：</p>\n<ol>\n<li>生产者只在仓库未满时进行生产苹果手（最多生产 10 部）并放入队列，仓库满时生产者进程被阻塞</li>\n<li>消费者只在仓库非空时进行消费，仓库为空时消费者进程被阻塞</li>\n<li>当消费者发现仓库为空时通知生产者生产</li>\n<li>当生产者发现仓库满时通知消费者</li>\n</ol>\n<p>&lt;!–code￼156–&gt;</p>\n<h5 id=\"semaphore-信号量\"><a class=\"anchor\" href=\"#semaphore-信号量\">❡</a> <strong>Semaphore</strong> <strong>信号量</strong></h5>\n<h6 id=\"案例\"><a class=\"anchor\" href=\"#案例\">❡</a> <strong>案例</strong></h6>\n<p>需求描述，某公共厕所共有 3 个蹲位 (3 个信号量)，突然来了 10 个人，请使用 Semaphore 来模拟此场景。</p>\n<p>&lt;!–code￼157–&gt;</p>\n<h5 id=\"线程等待挂起唤醒终止\"><a class=\"anchor\" href=\"#线程等待挂起唤醒终止\">❡</a> <strong>线程等待，挂起，唤醒，终止</strong></h5>\n<h6 id=\"1-线程等待join\"><a class=\"anchor\" href=\"#1-线程等待join\">❡</a> <strong>1.</strong> <strong>线程等待 ****Join</strong></h6>\n<p>在继续执行标准的 COM 和 SendMessage 消息泵处理期间，阻止调用线程，直到由该实例表示的线程</p>\n<p>终止。</p>\n<p>大白话就是，将执行权交给当前的实例线程，直到该线程的任务完成。</p>\n<p><strong>不等待</strong></p>\n<p>&lt;!–code￼158–&gt;</p>\n<p><strong>Join**** 等待</strong></p>\n<p>&lt;!–code￼159–&gt;</p>\n<h6 id=\"2-挂起唤醒终止\"><a class=\"anchor\" href=\"#2-挂起唤醒终止\">❡</a> <strong>2.</strong> <strong>挂起，唤醒，终止</strong></h6>\n<p>&lt;!–code￼160–&gt;</p>\n<h5 id=\"线程池\"><a class=\"anchor\" href=\"#线程池\">❡</a> <strong>线程池</strong></h5>\n<p>&lt;!–code￼161–&gt;</p>\n<h3 id=\"异步编程\"><a class=\"anchor\" href=\"#异步编程\">❡</a> <strong>异步编程</strong></h3>\n<h4 id=\"task-类\"><a class=\"anchor\" href=\"#task-类\">❡</a> <strong>Task</strong> <strong>类</strong></h4>\n<h5 id=\"创建任务的三种方式\"><a class=\"anchor\" href=\"#创建任务的三种方式\">❡</a> <strong>创建任务的三种方式：</strong></h5>\n<p>&lt;!–code￼162–&gt;</p>\n<h5 id=\"任务等待的四种方式\"><a class=\"anchor\" href=\"#任务等待的四种方式\">❡</a> 任务等待的四种方式</h5>\n<p>&lt;!–code￼163–&gt;</p>\n<h5 id=\"执行延续任务\"><a class=\"anchor\" href=\"#执行延续任务\">❡</a> <strong>执行延续任务</strong></h5>\n<p>&lt;!–code￼164–&gt;</p>\n<h5 id=\"任务取消\"><a class=\"anchor\" href=\"#任务取消\">❡</a> <strong>任务取消</strong></h5>\n<p>Task 中有一个专门的类 CancellationTokenSource 来取消任务执行 。</p>\n<p>&lt;!–code￼165–&gt;</p>\n<p>​\tCancellationTokenSource 的功能不仅仅是取消任务执行，我们可以使用 source.CancelAfter (5000) 实现 5 秒后自动取消任务，也可以通过 source.Token.Register (Action action) 注册取消任务触发的回调函数，即任务被取消时注册的 action 会被执行 .</p>\n<p>&lt;!–code￼166–&gt;</p>\n<h5 id=\"await-与-async\"><a class=\"anchor\" href=\"#await-与-async\">❡</a> <strong>await</strong> <strong>与</strong> <strong>async</strong></h5>\n<h4 id=\"异步方法\"><a class=\"anchor\" href=\"#异步方法\">❡</a> <strong>异步方法</strong></h4>\n<p>异步方法必须用 async 修饰，方法名一般以 Async 结尾，这是一种命名规范</p>\n<p>&lt;!–code￼167–&gt;</p>\n<h5 id=\"异步等待\"><a class=\"anchor\" href=\"#异步等待\">❡</a> <strong>异步等待</strong></h5>\n<p>如果某些方法的返回值，你需要立马得到结果才可以进行下一步操作时，可以使用 await 完成异步方法的完成。</p>\n<h5 id=\"等待结果\"><a class=\"anchor\" href=\"#等待结果\">❡</a> <strong>等待结果</strong></h5>\n<p>&lt;!–code￼168–&gt;</p>\n<p>也可以这样拿结果</p>\n<p>&lt;!–code￼169–&gt;</p>\n<p>productTask.Result 其实也是等待结果的作用。</p>\n<h4 id=\"thread-与-task的区别面试点\"><a class=\"anchor\" href=\"#thread-与-task的区别面试点\">❡</a> <strong>Thread</strong> <strong>与</strong> <strong>Task**** 的区别（面试点）</strong></h4>\n<ol>\n<li>\n<p>Task 是基于 Thread 的，是比较高层级的封装（它是在线程池的基础之上）， Task 最终还是需要 Thread 来执行</p>\n</li>\n<li>\n<p>Task 默认使用后台线程执行， Thread 默认使用前台线程</p>\n</li>\n<li>\n<p>Task 可以有返回值， Thread 没有返回值 ， 虽然 Thread 可以通过 Start 方法参数来进行返回值处理，但十分不便。</p>\n</li>\n<li>\n<p>Task 可以执行后续操作， Thread 不能执行后续操作</p>\n</li>\n<li>\n<p>Task 可取消任务执行， Thread 不行</p>\n</li>\n<li>\n<p>异常传播 ， Thread 在父方法上获取不到异常，而 Task 可以。</p>\n</li>\n</ol>\n<h3 id=\"并行任务\"><a class=\"anchor\" href=\"#并行任务\">❡</a> 并行任务</h3>\n<p>&lt;!–code￼170–&gt;</p>\n<p>&lt;!–code￼171–&gt;</p>\n<h3 id=\"threadlocalt\"><a class=\"anchor\" href=\"#threadlocalt\">❡</a> Threadlocal&lt;T&gt;</h3>\n<p>多个线程共享一个变量，但每个线程都希望具有独立的数据版本。</p>\n<p>&lt;!–code￼172–&gt;</p>\n<h3 id=\"asynclocalt\"><a class=\"anchor\" href=\"#asynclocalt\">❡</a> AsyncLocal&lt;T&gt;</h3>\n<p>&lt;!–code￼173–&gt;</p>\n<h3 id=\"通道\"><a class=\"anchor\" href=\"#通道\">❡</a> 通道</h3>\n<p>通道内部自动维护者一个线程安全的队列，数据的写入与读取可以在不同的线程上完成。</p>\n<h4 id=\"channelt\"><a class=\"anchor\" href=\"#channelt\">❡</a> Channel&lt;T&gt;</h4>\n<h5 id=\"createunboundedt没有容量限制\"><a class=\"anchor\" href=\"#createunboundedt没有容量限制\">❡</a> CreateUnbounded&lt;T&gt;–没有容量限制</h5>\n<p>&lt;!–code￼174–&gt;</p>\n<h5 id=\"createboundedt有容量限制背压模式\"><a class=\"anchor\" href=\"#createboundedt有容量限制背压模式\">❡</a> CreateBounded&lt;T&gt;–有容量限制，背压模式</h5>\n<p>&lt;!–code￼175–&gt;</p>\n<h3 id=\"网络编程已经操作过一遍后续还需要学习\"><a class=\"anchor\" href=\"#网络编程已经操作过一遍后续还需要学习\">❡</a> <strong>网络编程</strong>（已经操作过一遍，后续还需要学习）</h3>\n<h4 id=\"socket\"><a class=\"anchor\" href=\"#socket\">❡</a> <strong>Socket</strong></h4>\n<h5 id=\"客户端代码\"><a class=\"anchor\" href=\"#客户端代码\">❡</a> <strong>客户端代码</strong></h5>\n<p>&lt;!–code￼176–&gt;</p>\n<h5 id=\"服务端代码\"><a class=\"anchor\" href=\"#服务端代码\">❡</a> <strong>服务端代码</strong></h5>\n<p>&lt;!–code￼177–&gt;</p>\n<h3 id=\"常用工具类还没完整学习后续还需要学习\"><a class=\"anchor\" href=\"#常用工具类还没完整学习后续还需要学习\">❡</a> <strong>常用工具类</strong>（还没完整学习，后续还需要学习）</h3>\n<h4 id=\"1-压缩与解压缩\"><a class=\"anchor\" href=\"#1-压缩与解压缩\">❡</a> <strong>1.</strong> <strong>压缩与解压缩</strong></h4>\n<ol>\n<li>将老师提供的 utils 文件夹 中的 ZipHelper.cs 类 复制到当前你的项目中</li>\n<li>ZipHelper 依赖于<strong> ICSharpCode.SharpZipLib.dll</strong> ，通过 Nuget 可将其引用进来</li>\n<li>创建一个 winform 项目，布局如下</li>\n</ol>\n<p><img data-src=\"C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250102123924040.png\" alt=\"image-20250102123924040\" /></p>\n<p><img data-src=\"C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250101222012012.png\" alt=\"image-20250101222012012\" /></p>\n<h5 id=\"选择单文件\"><a class=\"anchor\" href=\"#选择单文件\">❡</a> <strong>选择单文件</strong></h5>\n<p>&lt;!–code￼178–&gt;</p>\n<h5 id=\"压缩单文件\"><a class=\"anchor\" href=\"#压缩单文件\">❡</a> <strong>压缩单文件</strong></h5>\n<p>&lt;!–code￼179–&gt;</p>\n<h5 id=\"选择多文件\"><a class=\"anchor\" href=\"#选择多文件\">❡</a> <strong>选择多文件</strong></h5>\n<p>&lt;!–code￼180–&gt;</p>\n<h5 id=\"压缩多文件\"><a class=\"anchor\" href=\"#压缩多文件\">❡</a> <strong>压缩多文件</strong></h5>\n<p>&lt;!–code￼181–&gt;</p>\n<h5 id=\"解压文件\"><a class=\"anchor\" href=\"#解压文件\">❡</a> <strong>解压文件</strong></h5>\n<p>&lt;!–code￼182–&gt;</p>\n<h5 id=\"全部压缩\"><a class=\"anchor\" href=\"#全部压缩\">❡</a> 全部压缩</h5>\n<p>&lt;!–code￼183–&gt;</p>\n<p>&lt;!–code￼184–&gt;</p>\n<h4 id=\"2-图片处理\"><a class=\"anchor\" href=\"#2-图片处理\">❡</a> <strong>2.</strong> <strong>图片处理</strong></h4>\n<ol>\n<li>从老师提供的 utils 文件夹中将 ImageHelper 类拷贝至当前你的项目中</li>\n<li>创建一个 winform 项目，布局如下</li>\n</ol>\n<p><img data-src=\"C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241216022419829.png\" alt=\"image-20241216022419829\" /></p>\n<h5 id=\"生成验证码\"><a class=\"anchor\" href=\"#生成验证码\">❡</a> <strong>生成验证码</strong></h5>\n<p>布局：</p>\n<p>选择 tabcontrol，然后选择 pictureBox，PlaceholderText 进行输入内嵌文本</p>\n<p><img data-src=\"C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250103201813120.png\" alt=\"image-20250103201813120\" /></p>\n<p>&lt;!–code￼185–&gt;</p>\n<h5 id=\"生成文字水印\"><a class=\"anchor\" href=\"#生成文字水印\">❡</a> <strong>生成文字水印</strong></h5>\n<p>&lt;!–code￼186–&gt;</p>\n<h5 id=\"生成图片水印\"><a class=\"anchor\" href=\"#生成图片水印\">❡</a> 生成图片水印</h5>\n<p>&lt;!–code￼187–&gt;</p>\n<h5 id=\"生成缩略图\"><a class=\"anchor\" href=\"#生成缩略图\">❡</a> <strong>生成缩略图</strong></h5>\n<ol>\n<li>\n<p>定义好枚举，表示若干缩略图大小</p>\n<p>&lt;!–code￼188–&gt;</p>\n<ol start=\"2\">\n<li>\n<p>从老师提供的 utils 文件夹将 EnumHelper 文件拷贝至当前你的项目中</p>\n</li>\n<li>\n<p>生成缩略图</p>\n<p>&lt;!–code￼189–&gt;</p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-npoi-操作\"><a class=\"anchor\" href=\"#3-npoi-操作\">❡</a> <strong>3. NPOI</strong> <strong>操作</strong></h4>\n<p>​\tNPOI，顾名思义，就是 POI 的.NET 版本。 那 POI 又是什么呢？ POI 是一套用 Java 写成的库，能够帮助开</p>\n<p>发者在没有安装微软 Office 的情况下读写 Office 97-2007 的文件， 支持的文件格式包括 xls，xlsx,</p>\n<p>doc,docx, ppt 等。</p>\n<p><strong>优缺点</strong></p>\n<ol>\n<li>\n<p>读写速度快（有个国外的兄弟回复说，他原来用 ExcelPackage 生成用了 4-5 个小时，现在只需要 4-5 分钟）</p>\n</li>\n<li>\n<p>稳定性好（相对于用 Office OIA 而言，毕竟那东西是基于 Automation 做的，在 Server 上跑个 Automation 的东西， 想想都觉得可怕），跑过了将近 1000 个测试用例（来自于 POI 的 testcase 目录）</p>\n</li>\n<li>\n<p>API 简单易用，当然这得感谢 POI 的设计师们 第五，完美支持 Excel 2003 格式（据说 myxls 无法正确读取 xls 模板，但 NPOI 可以），以后也许是所有 Office 2003 格式</p>\n</li>\n</ol>\n<p><strong>缺点</strong></p>\n<p>​\t大文件操作占内存，对于数据量较大的文件导入操作可能不太支持。</p>\n<p><strong>功能实现</strong></p>\n<p>​\tNuget 引用包：NPOI，microsoft.entityframeworkcore，microsoft.entityframeworkcore.sqlserver</p>\n<h5 id=\"excel导入\"><a class=\"anchor\" href=\"#excel导入\">❡</a> <strong>Excel**** 导入</strong></h5>\n<p>​\tHtml 代码</p>\n<p>&lt;!–code￼190–&gt;</p>\n<p>第一种实现方式：</p>\n<p>注意点：id 得是 primary key 主键才行，不然会有很多问题。</p>\n<p><img data-src=\"C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250103231602694.png\" alt=\"image-20250103231602694\" /></p>\n<p>&lt;!–code￼191–&gt;</p>\n<p>第二种实现方式 （使用工具类）:</p>\n<p>​\t从 utils 文件夹中拷贝 ExcelHelper 工具类至当前项目中，ExcelHelper 中对 IWorkBook 接口扩展了 Import 方法</p>\n<p>&lt;!–code￼192–&gt;</p>\n<h5 id=\"excel-导出\"><a class=\"anchor\" href=\"#excel-导出\">❡</a> <strong>Excel</strong> <strong>导出</strong></h5>\n<p>​\tExcelHelper 中对 IWorkBook 接口扩展了 Export 方法</p>\n<p>&lt;!–code￼193–&gt;</p>\n<h4 id=\"4-easyexcel-操作\"><a class=\"anchor\" href=\"#4-easyexcel-操作\">❡</a> <strong>4. EasyExcel</strong> <strong>操作</strong></h4>\n<pre><code>EasyExcel是一个简单、省内存的读写Excel的开源项目。在尽可能节约内存的情况下支持读写百M的Excel。\n</code></pre>\n<p>​\t官网地址： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lYXN5ZXhjZWwub3BlbnNvdXJjZS5hbGliYWJhLmNvbS8lRUYlQkMlODglRTklOTglQkYlRTklODclOEMlRTUlODclQkElRTUlOTMlODElRUYlQkMlODk=\">https://easyexcel.opensource.alibaba.com/（阿里出品）</span> ， UP 主也推荐使用 EasyExcel。</p>\n<p>​\tNuget 引用包： Rong.EasyExcel</p>\n<p>​\tup 主试过使用 EasyExcel 对 100 万条数据的 excel 进行操作过，并无性能瓶颈。</p>\n<h5 id=\"导入操作\"><a class=\"anchor\" href=\"#导入操作\">❡</a> **\t导入操作 **</h5>\n<ol>\n<li>\n<p>准备实例类</p>\n<p>&lt;!–code￼194–&gt;</p>\n<p>IgnoreColumn: 设置忽略某字段</p>\n<p>Display: 与 Excel 表头形成映射关系，Name 属性值必须要与表头的列名保持一致</p>\n</li>\n<li>\n<p>在 Program 类中将 EasyExcel 相关服务进行注册</p>\n<p>&lt;!–code￼195–&gt;</p>\n</li>\n<li>\n<p>注入服务</p>\n<p>&lt;!–code￼196–&gt;</p>\n</li>\n<li>\n<p>完成导入</p>\n<p>&lt;!–code￼197–&gt;</p>\n<p>注意：需要把多余的 sheet 删掉</p>\n</li>\n</ol>\n<h5 id=\"导出操作\"><a class=\"anchor\" href=\"#导出操作\">❡</a> <strong>导出操作</strong></h5>\n<ol>\n<li>\n<p>注入导出服务</p>\n<p>&lt;!–code￼198–&gt;</p>\n<p>注意：需要把多余的 sheet 删掉</p>\n<p><strong>导出操作</strong></p>\n<ol>\n<li>\n<p>注入导出服务</p>\n<p>&lt;!–code￼199–&gt;</p>\n</li>\n<li>\n<p>实现导出</p>\n<p>&lt;!–code￼200–&gt;</p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"5-雪花算法\"><a class=\"anchor\" href=\"#5-雪花算法\">❡</a> <strong>5.</strong> <strong>雪花算法</strong></h4>\n<h5 id=\"1-传统的主键策略\"><a class=\"anchor\" href=\"#1-传统的主键策略\">❡</a> <strong>1.</strong> <strong>传统的主键策略</strong></h5>\n<p><strong>主键自增</strong></p>\n<p>​\t传统的主键自增在分布式系统中极易出现主键重复情况，特别是在高并发的情况下。</p>\n<p><strong>GUID</strong></p>\n<p>​\t GUID 的主要目的是产生完全唯一的数字。在理想情况下，任何计算机和计算机集群都不会生成两个相</p>\n<p>同的 GUID。GUID 的总数也足够大，达到了 2<sup>128（3.4×10</sup>38）个，所以随机生成两个相同 GUID 的可</p>\n<p>能性是非常小的，但并不为 0。所以，用于生成 GUID 的算法通常都加入了非随机的参数（如时间），以</p>\n<p>保证这种重复的情况不会发生。</p>\n<p>缺点：</p>\n<p>1、存储空间大（16 byte），因此它将会占用更多的磁盘大小。 如果你建的索引越多， 影响越严重。</p>\n<p>2、很难记忆。join 操作性能比整数要低。</p>\n<p>3、没有内置的函数获取最新产生的 guid 主键。</p>\n<p>4、GUID 做主键将会添加到表上的其他索引中，因此会降低性能，影响插入速度。</p>\n<p>5、GUID 之间比较大小相对数字慢不少， 影响查询速度</p>\n<h5 id=\"2-snowflake算法-分布式id\"><a class=\"anchor\" href=\"#2-snowflake算法-分布式id\">❡</a> <strong>2. SnowFlake<strong><strong> 算法</strong></strong> -<strong><strong> 分布式</strong></strong> ID</strong></h5>\n<pre><code>SnowFlake算法生成id的结果是一个64bit大小的整数 ,它是一个分布式ID,分布式ID 具有以下特点：\n</code></pre>\n<p><strong>优点：</strong></p>\n<ol>\n<li>\n<p>毫秒数在高位，自增序列在低位，整个 ID 都是趋势递增的。</p>\n</li>\n<li>\n<p>作为 DB 表的主键，索引效率高。</p>\n</li>\n<li>\n<p>不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成 ID 的性能也是非常高的。</p>\n</li>\n<li>\n<p>高性能高可用：生成时不依赖于数据库，完全在内存中生成。</p>\n</li>\n<li>\n<p>容量大，每秒中能生成数百万的自增 ID。</p>\n</li>\n<li>\n<p>可以根据自身业务特性分配 bit 位，非常灵活。</p>\n</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。</li>\n<li>不是严格全局递增的 (有点像莫须有的罪名，也不算是缺点)。</li>\n</ol>\n<h5 id=\"3-原理结构图\"><a class=\"anchor\" href=\"#3-原理结构图\">❡</a> <strong>3.</strong> <strong>原理结构图</strong></h5>\n<p><img data-src=\"C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241216020145995.png\" alt=\"image-20241216020145995\" /></p>\n<ol>\n<li>\n<p>1bit，不用，因为二进制中最高位是符号位，1 表示负数，0 表示正数。生成的 id 一般都是用整数，所以最高位固定为 0。</p>\n</li>\n<li>\n<p>41bit 时间戳，毫秒级。可以表示的数值范围是 （2^41-1），转换成单位年则是 69 年。</p>\n</li>\n<li>\n<p>10bit 工作机器 ID，用来表示工作机器的 ID，包括 5 位 datacenterId 和 5 位 workerId。也就是最多可以部署 1024 台雪花机器。</p>\n</li>\n<li>\n<p>12bit 序列号，用来记录同毫秒内产生的不同 id，12 位可以表示的最大整数为 4095，来表示同一机器同一时间截（毫秒) 内产生的 4095 个 ID 序号。 如果超过这个数字，则会等下一毫秒再生成</p>\n</li>\n</ol>\n<p><strong>服务一定需要开启才有用，而且端口号得用开启后的端口 6379 才行不然连接不上</strong></p>\n<p><strong>redis-server.exe redis.windows.conf 执行该命令</strong></p>\n<h5 id=\"4-net-实现\"><a class=\"anchor\" href=\"#4-net-实现\">❡</a> <strong>4. .Net</strong> <strong>实现</strong></h5>\n<p>在提供的 utils 文件夹中拷贝 Snowflake 文件夹至当前项目中，里面包含了 IdWorker（雪花语法的具体实现）</p>\n<p>&lt;!–code￼201–&gt;</p>\n<h5 id=\"5-雪花算法常见问题\"><a class=\"anchor\" href=\"#5-雪花算法常见问题\">❡</a> <strong>5.</strong> <strong>雪花算法常见问题</strong></h5>\n<p>​\t其实我们之前有提到工作机器 Id 的作用，就是用于解决分布式 Id 重复的问题，这个 workerId 是通过构造</p>\n<p>方法传入的，如果我们用 10 位来存储这个值，那就是最多支持 1024 个节点</p>\n<p><strong>WorkerId</strong> <strong>重复问题</strong></p>\n<p>​\t如果 workerId 相同，意味着在同一毫秒内，生成的雪花 Id 是有非常大的机率重复。虽然雪花 Id 共 64 位，但是同一毫秒，同一个 workerId ，意味着前 42+10 = 52 位 都是相同的数字，仅靠 剩下的 12 位序列号是很难保证分布式系统中雪花 ID 不重复。<strong>所以不同的服务器，它所用的<strong><strong> WorkerId</strong></strong> 必须不同</strong>，这样才能尽可能的避免并发情况下 Id 重复问题。</p>\n<p><strong>解决方案</strong></p>\n<ol>\n<li>\n<p>在 redis 中存储一个当前 workerId 的最大值</p>\n</li>\n<li>\n<p>每次生成 workerId 时，从 redis 中获取到当前 workerId 最大值，并 + 1 作为当前 workerId，并存入 redis</p>\n</li>\n<li>\n<p>如果 workerId 为 1023，自增为 1024，则重置 0，作为当前 workerId，并存入 redis</p>\n</li>\n<li>\n<p>IdWorker 这个类必须设置为单例模式</p>\n</li>\n</ol>\n<p><strong>代码实现</strong></p>\n<ol>\n<li>项目中添加 Nuget 包，搜索<strong> Microsoft.Extensions.Caching.StackExchangeRedis</strong>（版本一定要比 redis 的版本低才行）</li>\n<li>优化雪花算法工具包封装类</li>\n</ol>\n<p>&lt;!–code￼202–&gt;</p>\n<h3 id=\"linq-高级查询\"><a class=\"anchor\" href=\"#linq-高级查询\">❡</a> <strong>Linq</strong> <strong>高级查询</strong></h3>\n<h4 id=\"延迟执行与强制立即执行\"><a class=\"anchor\" href=\"#延迟执行与强制立即执行\">❡</a> 延迟执行与强制立即执行</h4>\n<p>LinQ 查询是延迟执行，运行到 foreach 语句处会跳回 select 语句处。</p>\n<p>&lt;!–code￼203–&gt;</p>\n<h4 id=\"linq实现的方式\"><a class=\"anchor\" href=\"#linq实现的方式\">❡</a> <strong>Linq**** 实现的方式</strong></h4>\n<p>&lt;!–code￼204–&gt;</p>\n<h4 id=\"联合查询\"><a class=\"anchor\" href=\"#联合查询\">❡</a> 联合查询</h4>\n<p>&lt;!–code￼205–&gt;</p>\n<h4 id=\"嵌套查询\"><a class=\"anchor\" href=\"#嵌套查询\">❡</a> 嵌套查询</h4>\n<p>&lt;!–code￼206–&gt;</p>\n<h4 id=\"linq-标准语法\"><a class=\"anchor\" href=\"#linq-标准语法\">❡</a> <strong>Linq -</strong> <strong>标准语法</strong></h4>\n<p>&lt;!–code￼207–&gt;</p>\n<p>&lt;!–code￼208–&gt;</p>\n<h1 id=\"\"><a class=\"anchor\" href=\"#\">❡</a> </h1>\n",
            "tags": [
                "后端",
                "C#"
            ]
        },
        {
            "id": "http://whw-colab.github.io/2025/04/15/hello-world/",
            "url": "http://whw-colab.github.io/2025/04/15/hello-world/",
            "title": "Hello World",
            "date_published": "2025-04-15T07:04:41.338Z",
            "content_html": "<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"quick-start\"><a class=\"anchor\" href=\"#quick-start\">❡</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"anchor\" href=\"#create-a-new-post\">❡</a> Create a new post</h3>\n<p>&lt;!–code￼0–&gt;</p>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"run-server\"><a class=\"anchor\" href=\"#run-server\">❡</a> Run server</h3>\n<p>&lt;!–code￼1–&gt;</p>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"generate-static-files\"><a class=\"anchor\" href=\"#generate-static-files\">❡</a> Generate static files</h3>\n<p>&lt;!–code￼2–&gt;</p>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"anchor\" href=\"#deploy-to-remote-sites\">❡</a> Deploy to remote sites</h3>\n<p>&lt;!–code￼3–&gt;</p>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n",
            "tags": []
        }
    ]
}